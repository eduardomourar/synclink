{
  "version": 3,
  "sources": ["../../src/synclink.ts", "../../src/protocol.ts", "../../src/request_response.ts", "../../src/types.ts", "../../src/shared_array_buffer.ts", "../../src/task.ts", "../../src/async_task.ts", "../../src/fake_message_channel.ts", "../../src/transfer_handlers.ts"],
  "sourcesContent": ["/**\n * Copyright 2019 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport { Endpoint } from \"./protocol\";\n\nexport {\n  TransferHandler,\n  transferHandlers,\n  transfer,\n} from \"./transfer_handlers\";\n\nexport {\n  ProxyOrClone,\n  UnproxyOrClone,\n  RemoteObject,\n  LocalObject,\n  ProxyMethods,\n  Remote,\n  Local,\n  createEndpoint,\n  releaseProxy,\n  proxyMarker,\n  ProxyMarked,\n} from \"./types\";\n\nexport { expose, wrap, windowEndpoint } from \"./async_task\";\n\nexport { interrupt_buffer, setInterruptHandler, Syncifier } from \"./task\";\n\nimport {\n  transferHandlers,\n  throwTransferHandler,\n  proxyTransferHandler,\n} from \"./transfer_handlers\";\nexport { FakeMessageChannel } from \"./fake_message_channel\";\n\nexport { proxy } from \"./transfer_handlers\";\n\ntransferHandlers.set(\"throw\", throwTransferHandler);\ntransferHandlers.set(\"proxy\", proxyTransferHandler);\n\ntransferHandlers.set(\"headers\", {\n  canHandle(value: unknown): value is Headers {\n    return Object.prototype.toString.call(value) === \"[object Headers]\";\n  },\n  serialize(value: Headers): [[string, string][], Transferable[]] {\n    return [Array.from(value as any), []];\n  },\n  deserialize(value: [string, string][]): Headers {\n    return new Headers(value);\n  },\n});\n", "/**\n * Copyright 2019 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport interface EventSource {\n  addEventListener(\n    type: string,\n    listener: EventListenerOrEventListenerObject,\n    options?: {},\n  ): void;\n\n  removeEventListener(\n    type: string,\n    listener: EventListenerOrEventListenerObject,\n    options?: {},\n  ): void;\n}\n\nexport interface PostMessageWithOrigin {\n  postMessage(\n    message: any,\n    targetOrigin: string,\n    transfer?: Transferable[],\n  ): void;\n}\n\nexport interface Endpoint extends EventSource {\n  postMessage(message: any, transfer?: Transferable[]): void;\n  start?: () => void;\n  _bypass?: boolean;\n}\n\nexport const enum WireValueType {\n  RAW = \"RAW\",\n  PROXY = \"PROXY\",\n  THROW = \"THROW\",\n  HANDLER = \"HANDLER\",\n  ID = \"ID\",\n}\n\n// It's not possible to automatically generate a set of values from a const enum\n// https://github.com/microsoft/TypeScript/issues/21391\n\n// This dance allows us to hand write the value set in a type safe way -- if a\n// case is added to or removed from the enum without updating the value set,\n// it's a type error.\nconst wireValueTypeRecord: Record<keyof typeof WireValueType, number> = {\n  [WireValueType.RAW]: 1,\n  [WireValueType.PROXY]: 1,\n  [WireValueType.THROW]: 1,\n  [WireValueType.HANDLER]: 1,\n  [WireValueType.ID]: 1,\n};\nexport const wireValueTypeSet = new Set(\n  Object.keys(wireValueTypeRecord),\n) as Set<keyof typeof WireValueType>;\n\nexport interface RawWireValue {\n  id?: string;\n  type: WireValueType.RAW;\n  value: {};\n}\n\nexport interface HandlerWireValue {\n  id?: string;\n  type: WireValueType.HANDLER;\n  name: string;\n  value: unknown;\n}\n\nexport interface IdWireValue {\n  id?: string;\n  type: WireValueType.ID;\n  ownkeys: string[];\n  endpoint_uuid: string;\n  store_key: number;\n}\n\nexport interface ProxyWireValue {\n  id?: string;\n  type: WireValueType.PROXY;\n  message: Message;\n}\n\nexport type WireValue =\n  | RawWireValue\n  | HandlerWireValue\n  | IdWireValue\n  | ProxyWireValue;\n\nexport type MessageID = string;\n\nexport type StoreKey = number;\n\nexport const enum MessageType {\n  GET = \"GET\",\n  SET = \"SET\",\n  APPLY = \"APPLY\",\n  CONSTRUCT = \"CONSTRUCT\",\n  ENDPOINT = \"ENDPOINT\",\n  RELEASE = \"RELEASE\",\n  DESTROY = \"DESTROY\",\n}\n\n// It's not possible to automatically generate a set of values from a const enum\n// https://github.com/microsoft/TypeScript/issues/21391\n\n// This dance allows us to hand write the value set in a type safe way -- if a\n// case is added to or removed from the enum without updating the value set,\n// it's a type error.\nconst messageTypeRecord: Record<keyof typeof MessageType, number> = {\n  [MessageType.SET]: 1,\n  [MessageType.GET]: 1,\n  [MessageType.APPLY]: 1,\n  [MessageType.CONSTRUCT]: 1,\n  [MessageType.ENDPOINT]: 1,\n  [MessageType.RELEASE]: 1,\n  [MessageType.DESTROY]: 1,\n};\nexport const messageTypeSet = new Set(Object.keys(messageTypeRecord)) as Set<\n  keyof typeof MessageType\n>;\n\nexport interface GetMessage {\n  id?: MessageID;\n  store_key?: StoreKey;\n  type: MessageType.GET;\n  path: string[];\n}\n\nexport interface SetMessage {\n  id?: MessageID;\n  type: MessageType.SET;\n  store_key?: StoreKey;\n  path: string[];\n  value: WireValue;\n}\n\nexport interface ApplyMessage {\n  id?: MessageID;\n  type: MessageType.APPLY;\n  store_key?: StoreKey;\n  path: string[];\n  argumentList: WireValue[];\n}\n\nexport interface ConstructMessage {\n  id?: MessageID;\n  type: MessageType.CONSTRUCT;\n  store_key?: StoreKey;\n  path: string[];\n  argumentList: WireValue[];\n}\n\nexport interface EndpointMessage {\n  id?: MessageID;\n  type: MessageType.ENDPOINT;\n}\n\nexport interface ReleaseMessage {\n  id?: MessageID;\n  type: MessageType.RELEASE;\n  path: string[];\n}\n\nexport interface DestroyMessage {\n  id?: MessageID;\n  type: MessageType.DESTROY;\n  store_key: StoreKey;\n}\n\nexport type Message =\n  | GetMessage\n  | SetMessage\n  | ApplyMessage\n  | ConstructMessage\n  | EndpointMessage\n  | ReleaseMessage\n  | DestroyMessage;\n\ntype StaticAssert<T extends true> = T;\ntype AreDisjoint<S, T> = S & T extends never ? true : false;\ntype AssertMessageTypeAndWireTypeAreDisjoint = StaticAssert<\n  AreDisjoint<WireValueType, MessageType>\n>;\n", "import { Endpoint, Message, WireValue } from \"./protocol\";\nexport { requestResponseMessageInner, requestResponseMessage };\n\nfunction requestResponseMessageInner(\n  ep: Endpoint,\n): [string, Promise<WireValue>] {\n  const id = generateUUID();\n  return [\n    id,\n    new Promise((resolve) => {\n      ep.addEventListener(\"message\", function l(ev: MessageEvent) {\n        if (!ev.data || !ev.data.id || ev.data.id !== id) {\n          return;\n        }\n        ep.removeEventListener(\"message\", l as any);\n        resolve(ev.data);\n      } as any);\n      if (ep.start) {\n        ep.start();\n      }\n    }),\n  ];\n}\n\nfunction requestResponseMessage(\n  ep: Endpoint,\n  msg: Message,\n  transfers?: Transferable[],\n): Promise<WireValue> {\n  let [id, promise] = requestResponseMessageInner(ep);\n  ep.postMessage({ id, ...msg }, transfers);\n  return promise;\n}\n\nexport let UUID_LENGTH = 63;\n\nfunction randomSegment() {\n  let result = Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16);\n  let pad = 15 - result.length;\n  if (pad > 0) {\n    result = Array.from({ length: pad }, (_) => 0).join(\"\") + result;\n  }\n  return result;\n}\n\nexport function generateUUID(): string {\n  let result = Array.from({ length: 4 }, randomSegment).join(\"-\");\n  if (result.length !== UUID_LENGTH) {\n    throw new Error(\"synclink internal error: UUID has the wrong length\");\n  }\n  return result;\n}\n", "import type { SynclinkTask } from \"./task\";\n\nexport const createEndpoint = Symbol(\"Synclink.endpoint\");\nexport const releaseProxy = Symbol(\"Synclink.releaseProxy\");\nexport const proxyMarker = Symbol(\"Synclink.proxy\");\n\n/**\n * Interface of values that were marked to be proxied with `synclink.proxy()`.\n * Can also be implemented by classes.\n */\nexport interface ProxyMarked {\n  [proxyMarker]: true;\n}\n\n/**\n * Takes a type and wraps it in a Promise, if it not already is one.\n * This is to avoid `Promise<Promise<T>>`.\n *\n * This is the inverse of `Unpromisify<T>`.\n */\ntype Promisify<T> = T extends Promise<unknown> ? T : Promise<T>;\n/**\n * Takes a type that may be Promise and unwraps the Promise type.\n * If `P` is not a Promise, it returns `P`.\n *\n * This is the inverse of `Promisify<T>`.\n */\ntype Unpromisify<P> = P extends Promise<infer T> ? T : P;\n\n/**\n * Takes the raw type of a remote property and returns the type that is visible to the local thread on the proxy.\n *\n * Note: This needs to be its own type alias, otherwise it will not distribute over unions.\n * See https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#distributive-conditional-types\n */\ntype RemoteProperty<T> =\n  // If the value is a method, synclink will proxy it automatically.\n  // Objects are only proxied if they are marked to be proxied.\n  // Otherwise, the property is converted to a Promise that resolves the cloned value.\n  T extends Function | ProxyMarked ? Remote<T> : SynclinkTask<T>;\n\n/**\n * Takes the raw type of a property as a remote thread would see it through a proxy (e.g. when passed in as a function\n * argument) and returns the type that the local thread has to supply.\n *\n * This is the inverse of `RemoteProperty<T>`.\n *\n * Note: This needs to be its own type alias, otherwise it will not distribute over unions. See\n * https://www.typescriptlang.org/docs/handbook/advanced-types.html#distributive-conditional-types\n */\ntype LocalProperty<T> = T extends Function | ProxyMarked ? Local<T> : UnTask<T>;\n\n/**\n * Proxies `T` if it is a `ProxyMarked`, clones it otherwise (as handled by structured cloning and transfer handlers).\n */\nexport type ProxyOrClone<T> = T extends ProxyMarked ? Remote<T> : T;\n/**\n * Inverse of `ProxyOrClone<T>`.\n */\nexport type UnproxyOrClone<T> = T extends RemoteObject<ProxyMarked>\n  ? Local<T>\n  : T;\n\n/**\n * Takes the raw type of a remote object in the other thread and returns the type as it is visible to the local thread\n * when proxied with `Synclink.proxy()`.\n *\n * This does not handle call signatures, which is handled by the more general `Remote<T>` type.\n *\n * @template T The raw type of a remote object as seen in the other thread.\n */\nexport type RemoteObject<T> = { [P in keyof T]: RemoteProperty<T[P]> };\n/**\n * Takes the type of an object as a remote thread would see it through a proxy (e.g. when passed in as a function\n * argument) and returns the type that the local thread has to supply.\n *\n * This does not handle call signatures, which is handled by the more general `Local<T>` type.\n *\n * This is the inverse of `RemoteObject<T>`.\n *\n * @template T The type of a proxied object.\n */\nexport type LocalObject<T> = { [P in keyof T]: LocalProperty<T[P]> };\n\n/**\n * Additional special synclink methods available on each proxy returned by `Synclink.wrap()`.\n */\nexport interface ProxyMethods {\n  [createEndpoint]: () => Promise<MessagePort>;\n  [releaseProxy]: () => SynclinkTask<void>;\n}\n\ntype UnTask<T> = T extends SynclinkTask<infer S> ? S : T;\ntype MaybePromise<T> = Promise<T> | T;\n\n/**\n * Takes the raw type of a remote object, function or class in the other thread and returns the type as it is visible to\n * the local thread from the proxy return value of `Synclink.wrap()` or `Synclink.proxy()`.\n */\nexport type Remote<T> =\n  // Handle properties\n  RemoteObject<T> &\n    // Handle call signature (if present)\n    (T extends (...args: infer TArguments) => infer TReturn\n      ? (\n          ...args: { [I in keyof TArguments]: UnproxyOrClone<TArguments[I]> }\n        ) => SynclinkTask<ProxyOrClone<Unpromisify<TReturn>>>\n      : unknown) &\n    // Handle construct signature (if present)\n    // The return of construct signatures is always proxied (whether marked or not)\n    (T extends { new (...args: infer TArguments): infer TInstance }\n      ? {\n          new (\n            ...args: {\n              [I in keyof TArguments]: UnproxyOrClone<TArguments[I]>;\n            }\n          ): SynclinkTask<Remote<TInstance>>;\n        }\n      : unknown) &\n    // Include additional special synclink methods available on the proxy.\n    ProxyMethods;\n\n/**\n * Takes the raw type of a remote object, function or class as a remote thread would see it through a proxy (e.g. when\n * passed in as a function argument) and returns the type the local thread has to supply.\n *\n * This is the inverse of `Remote<T>`. It takes a `Remote<T>` and returns its original input `T`.\n */\nexport type Local<T> =\n  // Omit the special proxy methods (they don't need to be supplied, synclink adds them)\n  Omit<LocalObject<T>, keyof ProxyMethods> &\n    // Handle call signatures (if present)\n    (T extends (...args: infer TArguments) => infer TReturn\n      ? (\n          ...args: { [I in keyof TArguments]: ProxyOrClone<TArguments[I]> }\n        ) => // The raw function could either be sync or async, but is always proxied automatically\n        MaybePromise<UnproxyOrClone<UnTask<TReturn>>>\n      : unknown) &\n    // Handle construct signature (if present)\n    // The return of construct signatures is always proxied (whether marked or not)\n    (T extends { new (...args: infer TArguments): infer TInstance }\n      ? {\n          new (\n            ...args: {\n              [I in keyof TArguments]: ProxyOrClone<TArguments[I]>;\n            }\n          ): // The raw constructor could either be sync or async, but is always proxied automatically\n          MaybePromise<Local<UnTask<TInstance>>>;\n        }\n      : unknown);\n", "let temp: typeof ArrayBuffer | typeof SharedArrayBuffer;\nif (typeof SharedArrayBuffer === \"undefined\") {\n  temp = ArrayBuffer;\n} else {\n  temp = SharedArrayBuffer;\n}\nexport default temp;\n", "import { Endpoint, Message, WireValue } from \"./protocol\";\n\nimport {\n  requestResponseMessage,\n  requestResponseMessageInner,\n  UUID_LENGTH,\n} from \"./request_response\";\nimport SharedArrayBuffer from \"./shared_array_buffer\";\n\nimport { fromWireValue } from \"./transfer_handlers\";\n\nlet decoder = new TextDecoder(\"utf-8\");\nlet encoder = new TextEncoder();\n\nconst SZ_BUF_SIZE_IDX = 0;\nconst SZ_BUF_FITS_IDX = 1;\n\nconst SZ_BUF_DOESNT_FIT = 0;\n\nfunction sleep(ms: number) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\ntype ResolvedSynclinkTask<T> = SynclinkTask<T> & { _result: T };\n\n/**\n * This is a \"syncifiable\" promise. It consists of a task to be dispatched on\n * another thread. It can be dispatched asynchronously (the easy way) or\n * synchronously (the harder way). Either way, this promise does not start out\n * as scheduled, you\n */\nexport class SynclinkTask<T> {\n  endpoint: Endpoint;\n  msg: Message;\n  extra: () => void;\n  transfers: Transferable[];\n\n  mode?: \"sync\" | \"async\";\n\n  _resolved: boolean;\n  _result?: T;\n  _exception?: any;\n\n  // Async only\n  _promise: Promise<any>;\n  _resolve!: (value: any) => void;\n  _reject!: (value: any) => void;\n\n  // sync only\n  taskId?: number;\n  _sync_gen?: Generator<undefined, any, undefined>;\n  size_buffer?: Int32Array;\n  signal_buffer?: Int32Array;\n\n  constructor(\n    endpoint: Endpoint,\n    msg: Message,\n    transfers: Transferable[] = [],\n    extra: () => void = () => {},\n  ) {\n    this.endpoint = endpoint;\n    this.msg = msg;\n    this.extra = extra;\n    this.transfers = transfers;\n    this._resolved = false;\n    this._promise = new Promise((resolve, reject) => {\n      this._resolve = resolve;\n      this._reject = reject;\n    });\n  }\n\n  schedule_async(): this {\n    if (this.mode === \"async\") {\n      // already scheduled\n      return this;\n    }\n    if (this.mode === \"sync\") {\n      throw new Error(\"Already synchronously scheduled\");\n    }\n    this.mode = \"async\";\n    this.do_async().then(\n      (value) => {\n        // console.log(\"resolving\", this.taskId, \"value\", value);\n        this._resolved = true;\n        this._result = value;\n        this._resolve(value);\n      },\n      (reason) => {\n        this._exception = reason;\n        this._reject(reason);\n      },\n    );\n    return this;\n  }\n\n  async then<S>(\n    onfulfilled: (value: T) => S,\n    onrejected: (reason: any) => S,\n  ): Promise<S> {\n    this.schedule_async();\n    return this._promise.then(onfulfilled, onrejected);\n  }\n\n  catch<S>(onrejected: (reason: any) => S): Promise<S> {\n    this.schedule_async();\n    return this._promise.catch(onrejected);\n  }\n\n  finally(onfinally: () => void): Promise<T> {\n    this.schedule_async();\n    return this._promise.finally(onfinally);\n  }\n\n  schedule_sync(): this {\n    if (this.mode === \"sync\") {\n      // already scheduled\n      return this;\n    }\n    if (this.mode === \"async\") {\n      throw new Error(\"Already asynchronously scheduled\");\n    }\n    this.mode = \"sync\";\n    Syncifier.scheduleTask(this);\n    this._sync_gen = this.do_sync();\n    this._sync_gen.next();\n    return this;\n  }\n\n  isResolved(): this is ResolvedSynclinkTask<T> {\n    return this._resolved;\n  }\n\n  poll(): boolean {\n    if (this.mode != \"sync\") {\n      throw new Error(\"Task not synchronously scheduled\");\n    }\n    let { done, value } = this._sync_gen!.next();\n    if (!done) {\n      return false;\n    }\n    try {\n      this._resolved = true;\n      this._result = fromWireValue(this.endpoint, value);\n    } catch (e) {\n      console.warn(\"synclink exception:\", e);\n      this._exception = e;\n    }\n    return true;\n  }\n\n  *do_sync(): Generator<undefined, string, undefined> {\n    // just use syncRequest.\n    let { endpoint, msg, transfers } = this;\n    let size_buffer = new Int32Array(new SharedArrayBuffer(8));\n    let signal_buffer = this.signal_buffer!;\n    let taskId = this.taskId;\n    // Ensure status is cleared. We will notify\n    let data_buffer = acquireDataBuffer(UUID_LENGTH);\n    // console.log(\"===requesting\", taskId);\n    endpoint.postMessage(\n      {\n        ...msg,\n        size_buffer,\n        data_buffer,\n        signal_buffer,\n        taskId,\n        syncify: true,\n      },\n      transfers,\n    );\n    yield;\n    if (Atomics.load(size_buffer, SZ_BUF_FITS_IDX) === SZ_BUF_DOESNT_FIT) {\n      // There wasn't enough space, make a bigger data_buffer.\n      // First read uuid for response out of current data_buffer\n      const id = decoder.decode(data_buffer.slice(0, UUID_LENGTH));\n      releaseDataBuffer(data_buffer);\n      const size = Atomics.load(size_buffer, SZ_BUF_SIZE_IDX);\n      data_buffer = acquireDataBuffer(size);\n      // console.log(\"===bigger data buffer\", taskId);\n      endpoint.postMessage({ id, data_buffer });\n      yield;\n    }\n    const size = Atomics.load(size_buffer, SZ_BUF_SIZE_IDX);\n    // console.log(\"===completing\", taskId);\n    return JSON.parse(decoder.decode(data_buffer.slice(0, size)));\n  }\n\n  async do_async(): Promise<T> {\n    let result = await requestResponseMessage(\n      this.endpoint,\n      this.msg,\n      this.transfers,\n    );\n    this.extra();\n    return fromWireValue(this.endpoint, result);\n  }\n\n  get result(): T {\n    if (this._exception) {\n      throw this._exception;\n    }\n    if (this.isResolved()) {\n      return this._result;\n    }\n    throw new Error(\"Not ready.\");\n  }\n\n  syncify(): T {\n    this.schedule_sync();\n    Syncifier.syncifyTask(this);\n    return this.result;\n  }\n}\n\nasync function signalRequester(\n  signal_buffer: Uint32Array,\n  taskId: number,\n): Promise<void> {\n  let index = (taskId >> 1) % 32;\n  let sleepTime = 1;\n  while (Atomics.compareExchange(signal_buffer, index + 1, 0, taskId) !== 0) {\n    // No Atomics.asyncWait except on Chrome =(\n    await sleep(sleepTime);\n    if (sleepTime < 32) {\n      // exponential backoff\n      sleepTime *= 2;\n    }\n  }\n  Atomics.or(signal_buffer, 0, 1 << index);\n  // @ts-ignore\n  Atomics.notify(signal_buffer, 0);\n}\n\n/**\n * Respond to a blocking request. Most of the work has already been done in\n * asynclink, we are just responsible here for getting the return value back to\n * the requester through this slightly convoluted Atomics protocol.\n *\n * @param endpoint A message port to receive messages from. Other thread is\n *        blocked, so we can't send messages back.\n * @param msg The message that was received. We will use it to read out the\n *        buffers to write the answer into. NOTE: requester owns buffers.\n * @param returnValue The value we want to send back to the requester. We have\n *        to encode it into data_buffer.\n */\nexport async function syncResponse(\n  endpoint: Endpoint,\n  msg: any,\n  returnValue: WireValue,\n): Promise<void> {\n  try {\n    let { size_buffer, data_buffer, signal_buffer, taskId } = msg;\n    // console.warn(msg);\n    let bytes = encoder.encode(JSON.stringify(returnValue));\n    let fits = bytes.length <= data_buffer.length;\n    Atomics.store(size_buffer, SZ_BUF_SIZE_IDX, bytes.length);\n    Atomics.store(size_buffer, SZ_BUF_FITS_IDX, +fits);\n    if (!fits) {\n      // console.log(\"      need larger buffer\", taskId)\n      // Request larger buffer\n      let [uuid, data_promise] = requestResponseMessageInner(endpoint);\n      // Write UUID into data_buffer so syncRequest knows where to respond to.\n      data_buffer.set(encoder.encode(uuid));\n      await signalRequester(signal_buffer, taskId);\n      // Wait for response with new bigger data_buffer\n      data_buffer = ((await data_promise) as any).data_buffer;\n    }\n    // Encode result into data_buffer\n    data_buffer.set(bytes);\n    Atomics.store(size_buffer, SZ_BUF_FITS_IDX, +true);\n    // @ts-ignore\n    // console.log(\"       signaling completion\", taskId)\n    await signalRequester(signal_buffer, taskId);\n  } catch (e) {\n    console.warn(e);\n  }\n}\n\nlet dataBuffers: Uint8Array[][] = [];\n\nfunction acquireDataBuffer(size: number): Uint8Array {\n  let powerof2 = Math.ceil(Math.log2(size));\n  if (!dataBuffers[powerof2]) {\n    dataBuffers[powerof2] = [];\n  }\n  let result = dataBuffers[powerof2].pop();\n  if (result) {\n    result.fill(0);\n    return result;\n  }\n  return new Uint8Array(new SharedArrayBuffer(2 ** powerof2));\n}\n\nfunction releaseDataBuffer(buffer: Uint8Array) {\n  let powerof2 = Math.ceil(Math.log2(buffer.byteLength));\n  dataBuffers[powerof2].push(buffer);\n}\n\n/**\n * Another thread can set this to a nonzero value to request an interrupt.\n */\nexport let interrupt_buffer = new Int32Array(new SharedArrayBuffer(4));\n\nlet handleInterrupt = () => {\n  interrupt_buffer[0] = 0;\n  throw new Error(\"Interrupted!\");\n};\n\n/**\n * Sets the interrupt handler. This is called when the computation is\n * interrupted. Should zero the interrupt buffer and throw an exception.\n * @param handler\n */\nexport function setInterruptHandler(handler: () => never) {\n  handleInterrupt = handler;\n}\n\nclass _Syncifier {\n  nextTaskId: Int32Array;\n  signal_buffer: Int32Array;\n  tasks: Map<number, SynclinkTask<any>>;\n  constructor() {\n    this.nextTaskId = new Int32Array([1]);\n    this.signal_buffer = new Int32Array(new SharedArrayBuffer(32 * 4 + 4));\n    this.tasks = new Map();\n  }\n\n  scheduleTask(task: SynclinkTask<any>): void {\n    task.taskId = this.nextTaskId[0];\n    this.nextTaskId[0] += 2;\n    task.signal_buffer = this.signal_buffer;\n    this.tasks.set(task.taskId, task);\n  }\n\n  waitOnSignalBuffer(): void {\n    console.log(\"waiting on signal buffer\");\n    const timeout = 50;\n    while (true) {\n      const status = Atomics.wait(this.signal_buffer, 0, 0, timeout);\n      switch (status) {\n        case \"ok\":\n        case \"not-equal\":\n          console.log(\"finished waiting on signal buffer\");\n          return;\n        case \"timed-out\":\n          if (interrupt_buffer[0] !== 0) {\n            handleInterrupt();\n          }\n          break;\n        default:\n          throw new Error(\"Unreachable\");\n      }\n    }\n  }\n\n  *tasksIdsToWakeup(): Generator<number, void, void> {\n    let flag = Atomics.load(this.signal_buffer, 0);\n    for (let i = 0; i < 32; i++) {\n      let bit = 1 << i;\n      if (flag & bit) {\n        Atomics.and(this.signal_buffer, 0, ~bit);\n        let wokenTask = Atomics.exchange(this.signal_buffer, i + 1, 0);\n        yield wokenTask;\n      }\n    }\n  }\n\n  pollTasks(task?: SynclinkTask<any>): boolean {\n    let result = false;\n    if (!task && this.tasks.size < 1) {\n      return true;\n    }\n    for (let wokenTaskId of this.tasksIdsToWakeup()) {\n      console.log(\"poll task\", wokenTaskId, \"looking for\",task);\n      let wokenTask = this.tasks.get(wokenTaskId);\n      if (!wokenTask) {\n        throw new Error(`Assertion error: unknown taskId ${wokenTaskId}.`);\n      }\n      if (wokenTask!.poll()) {\n        console.log(\"completed task \", wokenTaskId, wokenTask, wokenTask._result);\n        this.tasks.delete(wokenTaskId);\n        if (wokenTask === task) {\n          result = true;\n        }\n      }\n    }\n    return result;\n  }\n\n  syncifyTask(task: SynclinkTask<any>): void {\n    while (true) {\n      if (this.pollTasks(task)) {\n        return;\n      }\n      if (task.endpoint._bypass) {\n        throw new Error(\"oops!\");\n      }\n      this.waitOnSignalBuffer();\n    }\n  }\n}\nexport let Syncifier = new _Syncifier();\n\n(async function syncifyPollLoop() {\n  while (true) {\n    if (Syncifier.pollTasks()) {\n      return;\n    }\n    await sleep(20);\n  }\n})();\n", "import {\n  Endpoint,\n  EventSource,\n  Message,\n  MessageType,\n  messageTypeSet,\n  PostMessageWithOrigin,\n  WireValue,\n  WireValueType,\n  wireValueTypeSet,\n  StoreKey,\n} from \"./protocol\";\n\nimport { requestResponseMessage } from \"./request_response\";\n\nimport { createEndpoint, Remote, releaseProxy } from \"./types\";\nimport { proxy } from \"./transfer_handlers\";\nimport {\n  fromWireValue,\n  toWireValue,\n  transfer,\n  throwMarker,\n  storeCreate,\n  storeGetValue,\n  storeDeleteKey,\n} from \"./transfer_handlers\";\n\nimport { SynclinkTask, syncResponse } from \"./task\";\n\nfunction innerMessageHandler(obj_arg: any, ep: Endpoint, message: Message) {\n  const { id, path, store_key } = {\n    path: [] as string[],\n    store_key: undefined,\n    ...message,\n  };\n  let obj;\n  if (store_key) {\n    obj = storeGetValue(ep, store_key);\n  } else {\n    obj = obj_arg;\n  }\n  if (obj_arg === undefined && store_key === undefined) {\n    console.warn(obj_arg, message);\n    throw new Error(\"Internal synclink error!\");\n  }\n  const argumentList = ((message as any).argumentList || []).map((v: any) => {\n    if (v.type === WireValueType.PROXY) {\n      return innerMessageHandler(obj_arg, ep, v.message);\n    } else {\n      return fromWireValue(ep, v);\n    }\n  });\n  const last = path.pop();\n  let parent = path.reduce((obj, prop) => obj[prop], obj);\n  const rawValue = last ? parent[last] : obj;\n  if (!last) {\n    parent = undefined;\n  }\n  if (rawValue === undefined) {\n    switch (message.type) {\n      case MessageType.GET:\n      case MessageType.SET:\n        break;\n      default:\n        console.warn(\"Undefined\", obj, path, last);\n        throw new Error(\"undefined!!\" + ` ${obj}, ${path}, ${last}`);\n    }\n  }\n  switch (message.type) {\n    case MessageType.GET:\n      {\n        return rawValue;\n      }\n      break;\n    case MessageType.SET:\n      {\n        parent[last!] = fromWireValue(ep, message.value);\n        return true;\n      }\n      break;\n    case MessageType.APPLY:\n      {\n        if (last) {\n          return parent[last].apply(parent, argumentList);\n        } else {\n          return rawValue.apply(parent, argumentList);\n        }\n      }\n      break;\n    case MessageType.CONSTRUCT:\n      {\n        const value = new rawValue(...argumentList);\n        return proxy(value);\n      }\n      break;\n    case MessageType.ENDPOINT:\n      {\n        const { port1, port2 } = new MessageChannel();\n        expose(obj, port2);\n        return transfer(port1, [port1]);\n      }\n      break;\n    case MessageType.RELEASE:\n      {\n        return undefined;\n      }\n      break;\n    case MessageType.DESTROY:\n      {\n        storeDeleteKey(ep, store_key!);\n        return undefined;\n      }\n      break;\n    default:\n      return undefined;\n  }\n}\n\nexport function expose(obj_arg: any, ep: Endpoint = globalThis as any) {\n  const wrap = false;\n  exposeInner(obj_arg, ep, wrap);\n}\n\nfunction exposeInner(\n  obj_arg: any,\n  ep: Endpoint = globalThis as any,\n  wrap: boolean,\n) {\n  storeCreate(ep);\n  ep.addEventListener(\"message\", async function callback(ev: MessageEvent) {\n    if (!ev || !ev.data) {\n      return;\n    }\n    if (!messageTypeSet.has(ev.data.type)) {\n      if (!wireValueTypeSet.has(ev.data.type) && !ev.data.data_buffer) {\n        console.warn(\"Internal error on message:\", ev.data);\n        throw new Error(\n          `Synclink Internal error: Expected message.type to either be a MessageType or a WireValueType, got '${ev.data.type}'`,\n        );\n      }\n      // It was a response.\n      // TODO: assert that there is a requestResponseMessage waiting for this id?\n      return;\n    }\n    const message = ev.data as Message;\n    const { id, type, store_key } = { store_key: undefined, ...message };\n    if (wrap && store_key === undefined) {\n      // TODO: What are these messages doing?\n      return;\n    }\n    const sync = ev.data.syncify;\n    let returnValue;\n    try {\n      returnValue = innerMessageHandler(obj_arg, ep, message);\n      if (returnValue && returnValue.then) {\n        if (sync && ep._bypass) {\n          throw new Error(\"Cannot use syncify with bypass on an async method\");\n        }\n        returnValue = await returnValue;\n      }\n    } catch (value) {\n      returnValue = { value, [throwMarker]: 0 };\n    }\n    const [wireValue, transferables] = toWireValue(ep, returnValue);\n    if (sync) {\n      syncResponse(ep, ev.data, wireValue);\n    } else {\n      ep.postMessage({ ...wireValue, id }, transferables);\n    }\n    if (type === MessageType.RELEASE) {\n      // detach and deactivate after sending release response above.\n      ep.removeEventListener(\"message\", callback as any);\n      closeEndPoint(ep);\n    }\n  } as any);\n  if (ep.start) {\n    ep.start();\n  }\n}\n\nfunction isMessagePort(endpoint: Endpoint): endpoint is MessagePort {\n  return endpoint.constructor.name === \"MessagePort\";\n}\n\nfunction closeEndPoint(endpoint: Endpoint) {\n  if (isMessagePort(endpoint)) endpoint.close();\n}\n\nexport function wrap<T>(ep: Endpoint, target?: any): Remote<T> {\n  const wrap = true;\n  exposeInner(undefined, ep, wrap);\n  return createProxy<T>(ep, { target }) as any;\n}\n\nfunction throwIfProxyReleased(isReleased: boolean) {\n  if (isReleased) {\n    throw new Error(\"Proxy has been released and is not usable\");\n  }\n}\n\nexport function createProxy<T>(\n  ep: Endpoint,\n  {\n    store_key = undefined,\n    path = [],\n    target = function () {},\n  }: {\n    store_key?: StoreKey;\n    path?: (string | number | symbol)[];\n    target?: object;\n  },\n): Remote<T> {\n  let isProxyReleased = false;\n  const proxy = new Proxy(target, {\n    get(_target, prop) {\n      throwIfProxyReleased(isProxyReleased);\n      switch (prop) {\n        case \"$$ep\":\n          return ep;\n        case Symbol.toStringTag:\n          return \"SynclinkProxy\";\n        case releaseProxy:\n          return () => {\n            return new SynclinkTask(\n              ep,\n              {\n                type: MessageType.RELEASE,\n                path: path.map((p) => p.toString()),\n              },\n              [],\n              () => {\n                closeEndPoint(ep);\n                isProxyReleased = true;\n              },\n            );\n          };\n        case \"__destroy__\":\n          if (!store_key) {\n            return () => {};\n          }\n          return () => {\n            return new SynclinkTask(\n              ep,\n              {\n                type: MessageType.DESTROY,\n                store_key,\n              },\n              [],\n              () => {\n                isProxyReleased = true;\n              },\n            );\n          };\n        case \"_as_message\":\n          return () => {\n            return {\n              type: MessageType.GET,\n              store_key,\n              path: path.map((p) => p.toString()),\n            };\n          };\n        case \"then\":\n        case \"schedule_async\":\n        case \"schedule_sync\":\n        case \"syncify\":\n          if (path.length === 0 && prop === \"then\") {\n            return { then: () => proxy };\n          }\n          let r = new SynclinkTask(\n            ep,\n            {\n              type: MessageType.GET,\n              store_key,\n              path: path.map((p) => p.toString()),\n            },\n            [],\n            undefined,\n          );\n          return r[prop].bind(r);\n        default:\n          return createProxy(ep, { store_key, path: [...path, prop] });\n      }\n    },\n    set(_target, prop, rawValue) {\n      throwIfProxyReleased(isProxyReleased);\n      // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\n      // boolean. To show good will, we return true asynchronously \u00AF\\_(\u30C4)_/\u00AF\n      const [value, transferables] = toWireValue(ep, rawValue);\n      return requestResponseMessage(\n        ep,\n        {\n          type: MessageType.SET,\n          store_key,\n          path: [...path, prop].map((p) => p.toString()),\n          value,\n        },\n        transferables,\n      ).then((v) => fromWireValue(ep, v)) as any;\n    },\n    apply(_target, _thisArg, rawArgumentList) {\n      throwIfProxyReleased(isProxyReleased);\n      const last = path[path.length - 1];\n      if ((last as any) === createEndpoint) {\n        return requestResponseMessage(ep, {\n          type: MessageType.ENDPOINT,\n        }).then((v) => fromWireValue(ep, v));\n      }\n      // We just pretend that `bind()` didn\u2019t happen.\n      if (last === \"bind\") {\n        return createProxy(ep, { store_key, path: path.slice(0, -1) });\n      }\n      if (last === \"apply\") {\n        // temporary hack...\n        rawArgumentList = rawArgumentList[1];\n        path = path.slice(0, -1);\n      }\n      const [argumentList, transferables] = processArguments(\n        ep,\n        rawArgumentList,\n      );\n      return new SynclinkTask(\n        ep,\n        {\n          type: MessageType.APPLY,\n          store_key,\n          path: path.map((p) => p.toString()),\n          argumentList,\n        },\n        transferables,\n        undefined,\n      );\n    },\n    construct(_target, rawArgumentList) {\n      throwIfProxyReleased(isProxyReleased);\n      const [argumentList, transferables] = processArguments(\n        ep,\n        rawArgumentList,\n      );\n      return requestResponseMessage(\n        ep,\n        {\n          type: MessageType.CONSTRUCT,\n          store_key,\n          path: path.map((p) => p.toString()),\n          argumentList,\n        },\n        transferables,\n      ).then((v) => fromWireValue(ep, v));\n    },\n    ownKeys(_target) {\n      return [];\n    },\n  });\n  return proxy as any;\n}\n\nfunction myFlat<T>(arr: (T | T[])[]): T[] {\n  return Array.prototype.concat.apply([], arr);\n}\n\nfunction processArguments(\n  ep: Endpoint,\n  argumentList: any[],\n): [WireValue[], Transferable[]] {\n  const processed = argumentList.map((v) => toWireValue(ep, v));\n  return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];\n}\n\nexport function windowEndpoint(\n  w: PostMessageWithOrigin,\n  context: EventSource = self,\n  targetOrigin = \"*\",\n): Endpoint {\n  return {\n    postMessage: (msg: any, transferables: Transferable[]) =>\n      w.postMessage(msg, targetOrigin, transferables),\n    addEventListener: context.addEventListener.bind(context),\n    removeEventListener: context.removeEventListener.bind(context),\n  };\n}\n", "class FakeMessagePort {\n  _otherPort: FakeMessagePort;\n  _handlers: ((msg: { data: any }) => void)[] = [];\n  _bypass: boolean = true;\n  start() {}\n  close() {}\n\n  constructor() {\n    this._otherPort = this;\n  }\n\n  addEventListener(event: string, handler: (msg: { data: any }) => void) {\n    if (event === \"message\") {\n      this._handlers.push(handler);\n    }\n  }\n\n  removeEventListener(event: string, handler: (msg: { data: any }) => void) {\n    if (event !== \"message\") {\n      return;\n    }\n    let idx = this._handlers.indexOf(handler);\n    if (idx >= 0) {\n      this._handlers.splice(idx, 1);\n    }\n  }\n\n  postMessage(message: any, transfer: Transferable[]) {\n    for (const h of this._otherPort._handlers) {\n      h({ data: message });\n    }\n  }\n}\n\nclass FakeMessageChannel {\n  port1: FakeMessagePort;\n  port2: FakeMessagePort;\n  constructor() {\n    this.port1 = new FakeMessagePort();\n    this.port2 = new FakeMessagePort();\n    this.port1._otherPort = this.port2;\n    this.port2._otherPort = this.port1;\n  }\n}\n\nlet FakeMessageChannel1 =\n  FakeMessageChannel as unknown as typeof MessageChannel;\n\nexport { FakeMessageChannel1 as FakeMessageChannel };\n", "import { Endpoint, WireValue, WireValueType, StoreKey } from \"./protocol\";\nimport { generateUUID } from \"./request_response\";\nimport { createProxy, expose, wrap } from \"./async_task\";\nimport { FakeMessageChannel } from \"./fake_message_channel\";\nimport { ProxyMarked, proxyMarker } from \"./types\";\n\nexport const throwMarker = Symbol(\"Synclink.thrown\");\n\nconst transferCache = new WeakMap<any, Transferable[]>();\nexport function transfer<T>(obj: T, transfers: Transferable[]): T {\n  transferCache.set(obj, transfers);\n  return obj;\n}\n\nexport const isObject = (val: unknown): val is object =>\n  (typeof val === \"object\" && val !== null) || typeof val === \"function\";\n\n/**\n * Customizes the serialization of certain values as determined by `canHandle()`.\n *\n * @template T The input type being handled by this transfer handler.\n * @template S The serialized type sent over the wire.\n */\nexport interface TransferHandler<T, S> {\n  /**\n   * Gets called for every value to determine whether this transfer handler\n   * should serialize the value, which includes checking that it is of the right\n   * type (but can perform checks beyond that as well).\n   */\n  canHandle(value: unknown): value is T;\n\n  /**\n   * Gets called with the value if `canHandle()` returned `true` to produce a\n   * value that can be sent in a message, consisting of structured-cloneable\n   * values and/or transferrable objects.\n   */\n  serialize(value: T): [S, Transferable[]];\n\n  /**\n   * Gets called to deserialize an incoming value that was serialized in the\n   * other thread with this transfer handler (known through the name it was\n   * registered under).\n   */\n  deserialize(value: S): T;\n}\n\n/**\n * Allows customizing the serialization of certain values.\n */\nexport const transferHandlers = new Map<\n  string,\n  TransferHandler<unknown, unknown>\n>();\n\nfunction isArrayBufferOrView(obj: any): boolean {\n  return (\n    ArrayBuffer.isView(obj) ||\n    Object.prototype.toString.call(obj) === \"[object ArrayBuffer]\"\n  );\n}\n\nfunction isPlain(val: any) {\n  return (\n    !val ||\n    typeof val === \"string\" ||\n    typeof val === \"boolean\" ||\n    typeof val === \"number\" ||\n    Array.isArray(val) ||\n    isArrayBufferOrView(val) ||\n    !val.constructor ||\n    (val.constructor === Object &&\n      Object.prototype.toString.call(val) === \"[object Object]\")\n  );\n}\n\nfunction isSerializable(obj: any, transfers: Transferable[] = []) {\n  if (transfers.includes(obj)) {\n    return true;\n  }\n  if (!isPlain(obj)) {\n    return false;\n  }\n  for (var property in obj) {\n    if (obj.hasOwnProperty(property)) {\n      if (!isPlain(obj[property])) {\n        return false;\n      }\n      if (typeof obj[property] == \"object\") {\n        if (!isSerializable(obj[property], transfers)) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}\n\ninterface ThrownValue {\n  [throwMarker]: unknown; // just needs to be present\n  value: unknown;\n}\ntype SerializedThrownValue =\n  | { isError: true; value: Error }\n  | { isError: false; value: unknown };\n\n/**\n * Internal transfer handler to handle thrown exceptions.\n */\nexport const throwTransferHandler: TransferHandler<\n  ThrownValue,\n  SerializedThrownValue\n> = {\n  canHandle: (value): value is ThrownValue =>\n    isObject(value) && throwMarker in value,\n  serialize({ value }) {\n    let serialized: SerializedThrownValue;\n    if (value instanceof Error) {\n      serialized = {\n        isError: true,\n        value: {\n          message: value.message,\n          name: value.name,\n          stack: value.stack,\n        },\n      };\n    } else {\n      serialized = { isError: false, value };\n    }\n    return [serialized, []];\n  },\n  deserialize(serialized) {\n    if (serialized.isError) {\n      throw Object.assign(\n        new Error(serialized.value.message),\n        serialized.value,\n      );\n    }\n    throw serialized.value;\n  },\n};\n\nexport function toWireValue(\n  ep: Endpoint,\n  value: any,\n): [WireValue, Transferable[]] {\n  if (value && value.$$ep === ep) {\n    return [\n      {\n        type: WireValueType.PROXY,\n        message: value._as_message(),\n      },\n      [],\n    ];\n  }\n  if (value && value.constructor && value.constructor.name === \"SynclinkTask\") {\n    return [\n      {\n        type: WireValueType.PROXY,\n        message: value.msg,\n      },\n      [],\n    ];\n  }\n  if (ep._bypass) {\n    proxyFakeMessagePort = true;\n  }\n  try {\n    for (const [name, handler] of transferHandlers) {\n      if (handler.canHandle(value)) {\n        const [serializedValue, transferables] = handler.serialize(value);\n        return [\n          {\n            type: WireValueType.HANDLER,\n            name,\n            value: serializedValue,\n          },\n          transferables,\n        ];\n      }\n    }\n  } finally {\n    proxyFakeMessagePort = false;\n  }\n  if (isSerializable(value, transferCache.get(value))) {\n    return [\n      {\n        type: WireValueType.RAW,\n        value,\n      },\n      transferCache.get(value) || [],\n    ];\n  }\n  let store_key = storeNewValue(ep, value);\n  return [\n    {\n      type: WireValueType.ID,\n      store_key,\n      endpoint_uuid: (ep as any)[endpointUUID],\n      ownkeys: Object.getOwnPropertyNames(value),\n    },\n    [],\n  ];\n}\n\nexport function fromWireValue(ep: Endpoint, value: WireValue): any {\n  switch (value.type) {\n    case WireValueType.HANDLER:\n      return transferHandlers.get(value.name)!.deserialize(value.value);\n    case WireValueType.RAW:\n      return value.value;\n    case WireValueType.ID:\n      let this_uuid = (ep as any)[endpointUUID];\n      if (this_uuid === value.endpoint_uuid) {\n        return storeGetValue(ep, value.store_key);\n      } else {\n        return createProxy(ep, { store_key: value.store_key });\n      }\n  }\n}\n\nconst proxyStore = Symbol(\"Synclink.proxyStore\");\nconst endpointUUID = Symbol(\"Synclink.endpointUUID\");\n\nexport function storeCreate(obj: any) {\n  if (proxyStore in obj) {\n    return;\n  }\n  obj[proxyStore] = { objects: new Map(), counter: new Uint32Array([1]) };\n  obj[endpointUUID] = generateUUID();\n}\n\nexport function storeGetValue(obj: any, key: StoreKey) {\n  return obj[proxyStore].objects.get(key);\n}\n\nexport function storeNewValue(obj: any, value: any): StoreKey {\n  if (!(proxyStore in obj)) {\n    storeCreate(obj);\n  }\n  let { objects, counter } = obj[proxyStore];\n  while (objects.has(counter[0])) {\n    // Increment by two here (and below) because even integers are reserved\n    // for singleton constants\n    counter[0] += 2;\n  }\n  let key = counter[0];\n  counter[0] += 2;\n  objects.set(key, value);\n  return key;\n}\n\nexport function storeDeleteKey(obj: any, key: StoreKey): any {\n  let { objects } = obj[proxyStore];\n  objects.delete(key);\n  console.log(\"deleted\", key, objects);\n}\n\nexport function proxy<T>(obj: T): T & ProxyMarked {\n  return Object.assign(obj as any, { [proxyMarker]: true }) as any;\n}\n\nlet proxyFakeMessagePort = false;\n\n/**\n * Internal transfer handle to handle objects marked to proxy.\n */\nexport const proxyTransferHandler: TransferHandler<object, MessagePort> = {\n  canHandle: (val): val is ProxyMarked =>\n    isObject(val) && (val as ProxyMarked)[proxyMarker],\n  serialize(obj) {\n    const { port1, port2 } = (\n      proxyFakeMessagePort ? new FakeMessageChannel() : new MessageChannel()\n    ) as MessageChannel;\n    expose(obj, port1);\n    return [port2, [port2]];\n  },\n  deserialize(port) {\n    port.start();\n    return wrap(port);\n  },\n};\n"],
  "mappings": "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",
  "names": ["size", "obj", "wrap", "proxy", "transfer"]
}
