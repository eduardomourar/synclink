{
  "version": 3,
  "sources": ["../../src/protocol.ts", "../../src/request_response.ts", "../../src/types.ts", "../../src/shared_array_buffer.ts", "../../src/task.ts", "../../src/async_task.ts", "../../src/fake_message_channel.ts", "../../src/transfer_handlers.ts", "../../src/synclink.ts"],
  "sourcesContent": ["/**\n * Copyright 2019 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport interface EventSource {\n  addEventListener(\n    type: string,\n    listener: EventListenerOrEventListenerObject,\n    options?: {},\n  ): void;\n\n  removeEventListener(\n    type: string,\n    listener: EventListenerOrEventListenerObject,\n    options?: {},\n  ): void;\n}\n\nexport interface PostMessageWithOrigin {\n  postMessage(\n    message: any,\n    targetOrigin: string,\n    transfer?: Transferable[],\n  ): void;\n}\n\nexport interface Endpoint extends EventSource {\n  postMessage(message: any, transfer?: Transferable[]): void;\n  start?: () => void;\n  _bypass?: boolean;\n}\n\nexport const enum WireValueType {\n  RAW = \"RAW\",\n  PROXY = \"PROXY\",\n  THROW = \"THROW\",\n  HANDLER = \"HANDLER\",\n  ID = \"ID\",\n}\n\n// It's not possible to automatically generate a set of values from a const enum\n// https://github.com/microsoft/TypeScript/issues/21391\n\n// This dance allows us to hand write the value set in a type safe way -- if a\n// case is added to or removed from the enum without updating the value set,\n// it's a type error.\nconst wireValueTypeRecord: Record<keyof typeof WireValueType, number> = {\n  [WireValueType.RAW]: 1,\n  [WireValueType.PROXY]: 1,\n  [WireValueType.THROW]: 1,\n  [WireValueType.HANDLER]: 1,\n  [WireValueType.ID]: 1,\n};\nexport const wireValueTypeSet = new Set(\n  Object.keys(wireValueTypeRecord),\n) as Set<keyof typeof WireValueType>;\n\nexport interface RawWireValue {\n  id?: string;\n  type: WireValueType.RAW;\n  value: {};\n}\n\nexport interface HandlerWireValue {\n  id?: string;\n  type: WireValueType.HANDLER;\n  name: string;\n  value: unknown;\n}\n\nexport interface IdWireValue {\n  id?: string;\n  type: WireValueType.ID;\n  ownkeys: string[];\n  endpoint_uuid: string;\n  store_key: number;\n}\n\nexport interface ProxyWireValue {\n  id?: string;\n  type: WireValueType.PROXY;\n  message: Message;\n}\n\nexport type WireValue =\n  | RawWireValue\n  | HandlerWireValue\n  | IdWireValue\n  | ProxyWireValue;\n\nexport type MessageID = string;\n\nexport type StoreKey = number;\n\nexport const enum MessageType {\n  GET = \"GET\",\n  SET = \"SET\",\n  APPLY = \"APPLY\",\n  CONSTRUCT = \"CONSTRUCT\",\n  ENDPOINT = \"ENDPOINT\",\n  RELEASE = \"RELEASE\",\n  DESTROY = \"DESTROY\",\n}\n\n// It's not possible to automatically generate a set of values from a const enum\n// https://github.com/microsoft/TypeScript/issues/21391\n\n// This dance allows us to hand write the value set in a type safe way -- if a\n// case is added to or removed from the enum without updating the value set,\n// it's a type error.\nconst messageTypeRecord: Record<keyof typeof MessageType, number> = {\n  [MessageType.SET]: 1,\n  [MessageType.GET]: 1,\n  [MessageType.APPLY]: 1,\n  [MessageType.CONSTRUCT]: 1,\n  [MessageType.ENDPOINT]: 1,\n  [MessageType.RELEASE]: 1,\n  [MessageType.DESTROY]: 1,\n};\nexport const messageTypeSet = new Set(Object.keys(messageTypeRecord)) as Set<\n  keyof typeof MessageType\n>;\n\nexport interface GetMessage {\n  id?: MessageID;\n  store_key?: StoreKey;\n  type: MessageType.GET;\n  path: string[];\n}\n\nexport interface SetMessage {\n  id?: MessageID;\n  type: MessageType.SET;\n  store_key?: StoreKey;\n  path: string[];\n  value: WireValue;\n}\n\nexport interface ApplyMessage {\n  id?: MessageID;\n  type: MessageType.APPLY;\n  store_key?: StoreKey;\n  path: string[];\n  argumentList: WireValue[];\n}\n\nexport interface ConstructMessage {\n  id?: MessageID;\n  type: MessageType.CONSTRUCT;\n  store_key?: StoreKey;\n  path: string[];\n  argumentList: WireValue[];\n}\n\nexport interface EndpointMessage {\n  id?: MessageID;\n  type: MessageType.ENDPOINT;\n}\n\nexport interface ReleaseMessage {\n  id?: MessageID;\n  type: MessageType.RELEASE;\n  path: string[];\n}\n\nexport interface DestroyMessage {\n  id?: MessageID;\n  type: MessageType.DESTROY;\n  store_key: StoreKey;\n}\n\nexport type Message =\n  | GetMessage\n  | SetMessage\n  | ApplyMessage\n  | ConstructMessage\n  | EndpointMessage\n  | ReleaseMessage\n  | DestroyMessage;\n\ntype StaticAssert<T extends true> = T;\ntype AreDisjoint<S, T> = S & T extends never ? true : false;\ntype AssertMessageTypeAndWireTypeAreDisjoint = StaticAssert<\n  AreDisjoint<WireValueType, MessageType>\n>;\n", "import { Endpoint, Message, WireValue } from \"./protocol\";\nexport { requestResponseMessageInner, requestResponseMessage };\n\nfunction requestResponseMessageInner(\n  ep: Endpoint,\n): [string, Promise<WireValue>] {\n  const id = generateUUID();\n  return [\n    id,\n    new Promise((resolve) => {\n      ep.addEventListener(\"message\", function l(ev: MessageEvent) {\n        if (!ev.data || !ev.data.id || ev.data.id !== id) {\n          return;\n        }\n        ep.removeEventListener(\"message\", l as any);\n        resolve(ev.data);\n      } as any);\n      if (ep.start) {\n        ep.start();\n      }\n    }),\n  ];\n}\n\nfunction requestResponseMessage(\n  ep: Endpoint,\n  msg: Message,\n  transfers?: Transferable[],\n): Promise<WireValue> {\n  let [id, promise] = requestResponseMessageInner(ep);\n  ep.postMessage({ id, ...msg }, transfers);\n  return promise;\n}\n\nexport let UUID_LENGTH = 63;\n\nfunction randomSegment() {\n  let result = Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16);\n  let pad = 15 - result.length;\n  if (pad > 0) {\n    result = Array.from({ length: pad }, (_) => 0).join(\"\") + result;\n  }\n  return result;\n}\n\nexport function generateUUID(): string {\n  let result = Array.from({ length: 4 }, randomSegment).join(\"-\");\n  if (result.length !== UUID_LENGTH) {\n    throw new Error(\"synclink internal error: UUID has the wrong length\");\n  }\n  return result;\n}\n", "import type { SynclinkTask } from \"./task\";\n\nexport const createEndpoint = Symbol(\"Synclink.endpoint\");\nexport const releaseProxy = Symbol(\"Synclink.releaseProxy\");\nexport const proxyMarker = Symbol(\"Synclink.proxy\");\n\n/**\n * Interface of values that were marked to be proxied with `synclink.proxy()`.\n * Can also be implemented by classes.\n */\nexport interface ProxyMarked {\n  [proxyMarker]: true;\n}\n\n/**\n * Takes a type and wraps it in a Promise, if it not already is one.\n * This is to avoid `Promise<Promise<T>>`.\n *\n * This is the inverse of `Unpromisify<T>`.\n */\ntype Promisify<T> = T extends Promise<unknown> ? T : Promise<T>;\n/**\n * Takes a type that may be Promise and unwraps the Promise type.\n * If `P` is not a Promise, it returns `P`.\n *\n * This is the inverse of `Promisify<T>`.\n */\ntype Unpromisify<P> = P extends Promise<infer T> ? T : P;\n\n/**\n * Takes the raw type of a remote property and returns the type that is visible to the local thread on the proxy.\n *\n * Note: This needs to be its own type alias, otherwise it will not distribute over unions.\n * See https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#distributive-conditional-types\n */\ntype RemoteProperty<T> =\n  // If the value is a method, synclink will proxy it automatically.\n  // Objects are only proxied if they are marked to be proxied.\n  // Otherwise, the property is converted to a Promise that resolves the cloned value.\n  T extends Function | ProxyMarked ? Remote<T> : SynclinkTask<T>;\n\n/**\n * Takes the raw type of a property as a remote thread would see it through a proxy (e.g. when passed in as a function\n * argument) and returns the type that the local thread has to supply.\n *\n * This is the inverse of `RemoteProperty<T>`.\n *\n * Note: This needs to be its own type alias, otherwise it will not distribute over unions. See\n * https://www.typescriptlang.org/docs/handbook/advanced-types.html#distributive-conditional-types\n */\ntype LocalProperty<T> = T extends Function | ProxyMarked ? Local<T> : UnTask<T>;\n\n/**\n * Proxies `T` if it is a `ProxyMarked`, clones it otherwise (as handled by structured cloning and transfer handlers).\n */\nexport type ProxyOrClone<T> = T extends ProxyMarked ? Remote<T> : T;\n/**\n * Inverse of `ProxyOrClone<T>`.\n */\nexport type UnproxyOrClone<T> = T extends RemoteObject<ProxyMarked>\n  ? Local<T>\n  : T;\n\n/**\n * Takes the raw type of a remote object in the other thread and returns the type as it is visible to the local thread\n * when proxied with `Synclink.proxy()`.\n *\n * This does not handle call signatures, which is handled by the more general `Remote<T>` type.\n *\n * @template T The raw type of a remote object as seen in the other thread.\n */\nexport type RemoteObject<T> = { [P in keyof T]: RemoteProperty<T[P]> };\n/**\n * Takes the type of an object as a remote thread would see it through a proxy (e.g. when passed in as a function\n * argument) and returns the type that the local thread has to supply.\n *\n * This does not handle call signatures, which is handled by the more general `Local<T>` type.\n *\n * This is the inverse of `RemoteObject<T>`.\n *\n * @template T The type of a proxied object.\n */\nexport type LocalObject<T> = { [P in keyof T]: LocalProperty<T[P]> };\n\n/**\n * Additional special synclink methods available on each proxy returned by `Synclink.wrap()`.\n */\nexport interface ProxyMethods {\n  [createEndpoint]: () => Promise<MessagePort>;\n  [releaseProxy]: () => SynclinkTask<void>;\n}\n\ntype UnTask<T> = T extends SynclinkTask<infer S> ? S : T;\ntype MaybePromise<T> = Promise<T> | T;\n\n/**\n * Takes the raw type of a remote object, function or class in the other thread and returns the type as it is visible to\n * the local thread from the proxy return value of `Synclink.wrap()` or `Synclink.proxy()`.\n */\nexport type Remote<T> =\n  // Handle properties\n  RemoteObject<T> &\n    // Handle call signature (if present)\n    (T extends (...args: infer TArguments) => infer TReturn\n      ? (\n          ...args: { [I in keyof TArguments]: UnproxyOrClone<TArguments[I]> }\n        ) => SynclinkTask<ProxyOrClone<Unpromisify<TReturn>>>\n      : unknown) &\n    // Handle construct signature (if present)\n    // The return of construct signatures is always proxied (whether marked or not)\n    (T extends { new (...args: infer TArguments): infer TInstance }\n      ? {\n          new (\n            ...args: {\n              [I in keyof TArguments]: UnproxyOrClone<TArguments[I]>;\n            }\n          ): SynclinkTask<Remote<TInstance>>;\n        }\n      : unknown) &\n    // Include additional special synclink methods available on the proxy.\n    ProxyMethods;\n\n/**\n * Takes the raw type of a remote object, function or class as a remote thread would see it through a proxy (e.g. when\n * passed in as a function argument) and returns the type the local thread has to supply.\n *\n * This is the inverse of `Remote<T>`. It takes a `Remote<T>` and returns its original input `T`.\n */\nexport type Local<T> =\n  // Omit the special proxy methods (they don't need to be supplied, synclink adds them)\n  Omit<LocalObject<T>, keyof ProxyMethods> &\n    // Handle call signatures (if present)\n    (T extends (...args: infer TArguments) => infer TReturn\n      ? (\n          ...args: { [I in keyof TArguments]: ProxyOrClone<TArguments[I]> }\n        ) => // The raw function could either be sync or async, but is always proxied automatically\n        MaybePromise<UnproxyOrClone<UnTask<TReturn>>>\n      : unknown) &\n    // Handle construct signature (if present)\n    // The return of construct signatures is always proxied (whether marked or not)\n    (T extends { new (...args: infer TArguments): infer TInstance }\n      ? {\n          new (\n            ...args: {\n              [I in keyof TArguments]: ProxyOrClone<TArguments[I]>;\n            }\n          ): // The raw constructor could either be sync or async, but is always proxied automatically\n          MaybePromise<Local<UnTask<TInstance>>>;\n        }\n      : unknown);\n", "let temp: typeof ArrayBuffer | typeof SharedArrayBuffer;\nif (typeof SharedArrayBuffer === \"undefined\") {\n  temp = ArrayBuffer;\n} else {\n  temp = SharedArrayBuffer;\n}\nexport default temp;\n", "import { Endpoint, Message, WireValue } from \"./protocol\";\n\nimport {\n  requestResponseMessage,\n  requestResponseMessageInner,\n  UUID_LENGTH,\n} from \"./request_response\";\nimport SharedArrayBuffer from \"./shared_array_buffer\";\n\nimport { fromWireValue } from \"./transfer_handlers\";\n\nlet decoder = new TextDecoder(\"utf-8\");\nlet encoder = new TextEncoder();\n\nconst SZ_BUF_SIZE_IDX = 0;\nconst SZ_BUF_FITS_IDX = 1;\n\nconst SZ_BUF_DOESNT_FIT = 0;\n\nfunction sleep(ms: number) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\ntype ResolvedSynclinkTask<T> = SynclinkTask<T> & { _result: T };\n\n/**\n * This is a \"syncifiable\" promise. It consists of a task to be dispatched on\n * another thread. It can be dispatched asynchronously (the easy way) or\n * synchronously (the harder way). Either way, this promise does not start out\n * as scheduled, you\n */\nexport class SynclinkTask<T> {\n  endpoint: Endpoint;\n  msg: Message;\n  extra: () => void;\n  transfers: Transferable[];\n\n  mode?: \"sync\" | \"async\";\n\n  _resolved: boolean;\n  _result?: T;\n  _exception?: any;\n\n  // Async only\n  _promise: Promise<any>;\n  _resolve!: (value: any) => void;\n  _reject!: (value: any) => void;\n\n  // sync only\n  taskId?: number;\n  _sync_gen?: Generator<undefined, any, undefined>;\n  size_buffer?: Int32Array;\n  signal_buffer?: Int32Array;\n\n  constructor(\n    endpoint: Endpoint,\n    msg: Message,\n    transfers: Transferable[] = [],\n    extra: () => void = () => {},\n  ) {\n    this.endpoint = endpoint;\n    this.msg = msg;\n    this.extra = extra;\n    this.transfers = transfers;\n    this._resolved = false;\n    this._promise = new Promise((resolve, reject) => {\n      this._resolve = resolve;\n      this._reject = reject;\n    });\n  }\n\n  schedule_async(): this {\n    if (this.mode === \"async\") {\n      // already scheduled\n      return this;\n    }\n    if (this.mode === \"sync\") {\n      throw new Error(\"Already synchronously scheduled\");\n    }\n    this.mode = \"async\";\n    this.do_async().then(\n      (value) => {\n        // console.log(\"resolving\", this.taskId, \"value\", value);\n        this._resolved = true;\n        this._result = value;\n        this._resolve(value);\n      },\n      (reason) => {\n        this._exception = reason;\n        this._reject(reason);\n      },\n    );\n    return this;\n  }\n\n  async then<S>(\n    onfulfilled: (value: T) => S,\n    onrejected: (reason: any) => S,\n  ): Promise<S> {\n    this.schedule_async();\n    return this._promise.then(onfulfilled, onrejected);\n  }\n\n  catch<S>(onrejected: (reason: any) => S): Promise<S> {\n    this.schedule_async();\n    return this._promise.catch(onrejected);\n  }\n\n  finally(onfinally: () => void): Promise<T> {\n    this.schedule_async();\n    return this._promise.finally(onfinally);\n  }\n\n  schedule_sync(): this {\n    if (this.mode === \"sync\") {\n      // already scheduled\n      return this;\n    }\n    if (this.mode === \"async\") {\n      throw new Error(\"Already asynchronously scheduled\");\n    }\n    this.mode = \"sync\";\n    Syncifier.scheduleTask(this);\n    this._sync_gen = this.do_sync();\n    this._sync_gen.next();\n    return this;\n  }\n\n  isResolved(): this is ResolvedSynclinkTask<T> {\n    return this._resolved;\n  }\n\n  poll(): boolean {\n    if (this.mode != \"sync\") {\n      throw new Error(\"Task not synchronously scheduled\");\n    }\n    let { done, value } = this._sync_gen!.next();\n    if (!done) {\n      return false;\n    }\n    try {\n      this._resolved = true;\n      this._result = fromWireValue(this.endpoint, value);\n    } catch (e) {\n      console.warn(\"synclink exception:\", e);\n      this._exception = e;\n    }\n    return true;\n  }\n\n  *do_sync(): Generator<undefined, string, undefined> {\n    // just use syncRequest.\n    let { endpoint, msg, transfers } = this;\n    let size_buffer = new Int32Array(new SharedArrayBuffer(8));\n    let signal_buffer = this.signal_buffer!;\n    let taskId = this.taskId;\n    // Ensure status is cleared. We will notify\n    let data_buffer = acquireDataBuffer(UUID_LENGTH);\n    // console.log(\"===requesting\", taskId);\n    endpoint.postMessage(\n      {\n        ...msg,\n        size_buffer,\n        data_buffer,\n        signal_buffer,\n        taskId,\n        syncify: true,\n      },\n      transfers,\n    );\n    yield;\n    if (Atomics.load(size_buffer, SZ_BUF_FITS_IDX) === SZ_BUF_DOESNT_FIT) {\n      // There wasn't enough space, make a bigger data_buffer.\n      // First read uuid for response out of current data_buffer\n      const id = decoder.decode(data_buffer.slice(0, UUID_LENGTH));\n      releaseDataBuffer(data_buffer);\n      const size = Atomics.load(size_buffer, SZ_BUF_SIZE_IDX);\n      data_buffer = acquireDataBuffer(size);\n      // console.log(\"===bigger data buffer\", taskId);\n      endpoint.postMessage({ id, data_buffer });\n      yield;\n    }\n    const size = Atomics.load(size_buffer, SZ_BUF_SIZE_IDX);\n    // console.log(\"===completing\", taskId);\n    return JSON.parse(decoder.decode(data_buffer.slice(0, size)));\n  }\n\n  async do_async(): Promise<T> {\n    let result = await requestResponseMessage(\n      this.endpoint,\n      this.msg,\n      this.transfers,\n    );\n    this.extra();\n    return fromWireValue(this.endpoint, result);\n  }\n\n  get result(): T {\n    if (this._exception) {\n      throw this._exception;\n    }\n    if (this.isResolved()) {\n      return this._result;\n    }\n    throw new Error(\"Not ready.\");\n  }\n\n  syncify(): T {\n    this.schedule_sync();\n    Syncifier.syncifyTask(this);\n    return this.result;\n  }\n}\n\nasync function signalRequester(\n  signal_buffer: Uint32Array,\n  taskId: number,\n): Promise<void> {\n  let index = (taskId >> 1) % 32;\n  let sleepTime = 1;\n  while (Atomics.compareExchange(signal_buffer, index + 1, 0, taskId) !== 0) {\n    // No Atomics.asyncWait except on Chrome =(\n    await sleep(sleepTime);\n    if (sleepTime < 32) {\n      // exponential backoff\n      sleepTime *= 2;\n    }\n  }\n  Atomics.or(signal_buffer, 0, 1 << index);\n  // @ts-ignore\n  Atomics.notify(signal_buffer, 0);\n}\n\n/**\n * Respond to a blocking request. Most of the work has already been done in\n * asynclink, we are just responsible here for getting the return value back to\n * the requester through this slightly convoluted Atomics protocol.\n *\n * @param endpoint A message port to receive messages from. Other thread is\n *        blocked, so we can't send messages back.\n * @param msg The message that was received. We will use it to read out the\n *        buffers to write the answer into. NOTE: requester owns buffers.\n * @param returnValue The value we want to send back to the requester. We have\n *        to encode it into data_buffer.\n */\nexport async function syncResponse(\n  endpoint: Endpoint,\n  msg: any,\n  returnValue: WireValue,\n): Promise<void> {\n  try {\n    let { size_buffer, data_buffer, signal_buffer, taskId } = msg;\n    // console.warn(msg);\n    let bytes = encoder.encode(JSON.stringify(returnValue));\n    let fits = bytes.length <= data_buffer.length;\n    Atomics.store(size_buffer, SZ_BUF_SIZE_IDX, bytes.length);\n    Atomics.store(size_buffer, SZ_BUF_FITS_IDX, +fits);\n    if (!fits) {\n      // console.log(\"      need larger buffer\", taskId)\n      // Request larger buffer\n      let [uuid, data_promise] = requestResponseMessageInner(endpoint);\n      // Write UUID into data_buffer so syncRequest knows where to respond to.\n      data_buffer.set(encoder.encode(uuid));\n      await signalRequester(signal_buffer, taskId);\n      // Wait for response with new bigger data_buffer\n      data_buffer = ((await data_promise) as any).data_buffer;\n    }\n    // Encode result into data_buffer\n    data_buffer.set(bytes);\n    Atomics.store(size_buffer, SZ_BUF_FITS_IDX, +true);\n    // @ts-ignore\n    // console.log(\"       signaling completion\", taskId)\n    await signalRequester(signal_buffer, taskId);\n  } catch (e) {\n    console.warn(e);\n  }\n}\n\nlet dataBuffers: Uint8Array[][] = [];\n\nfunction acquireDataBuffer(size: number): Uint8Array {\n  let powerof2 = Math.ceil(Math.log2(size));\n  if (!dataBuffers[powerof2]) {\n    dataBuffers[powerof2] = [];\n  }\n  let result = dataBuffers[powerof2].pop();\n  if (result) {\n    result.fill(0);\n    return result;\n  }\n  return new Uint8Array(new SharedArrayBuffer(2 ** powerof2));\n}\n\nfunction releaseDataBuffer(buffer: Uint8Array) {\n  let powerof2 = Math.ceil(Math.log2(buffer.byteLength));\n  dataBuffers[powerof2].push(buffer);\n}\n\n/**\n * Another thread can set this to a nonzero value to request an interrupt.\n */\nexport let interrupt_buffer = new Int32Array(new SharedArrayBuffer(4));\n\nlet handleInterrupt = () => {\n  interrupt_buffer[0] = 0;\n  throw new Error(\"Interrupted!\");\n};\n\n/**\n * Sets the interrupt handler. This is called when the computation is\n * interrupted. Should zero the interrupt buffer and throw an exception.\n * @param handler\n */\nexport function setInterruptHandler(handler: () => never) {\n  handleInterrupt = handler;\n}\n\nclass _Syncifier {\n  nextTaskId: Int32Array;\n  signal_buffer: Int32Array;\n  tasks: Map<number, SynclinkTask<any>>;\n  constructor() {\n    this.nextTaskId = new Int32Array([1]);\n    this.signal_buffer = new Int32Array(new SharedArrayBuffer(32 * 4 + 4));\n    this.tasks = new Map();\n  }\n\n  scheduleTask(task: SynclinkTask<any>): void {\n    task.taskId = this.nextTaskId[0];\n    this.nextTaskId[0] += 2;\n    task.signal_buffer = this.signal_buffer;\n    this.tasks.set(task.taskId, task);\n  }\n\n  waitOnSignalBuffer(): void {\n    console.log(\"waiting on signal buffer\");\n    const timeout = 50;\n    while (true) {\n      const status = Atomics.wait(this.signal_buffer, 0, 0, timeout);\n      switch (status) {\n        case \"ok\":\n        case \"not-equal\":\n          console.log(\"finished waiting on signal buffer\");\n          return;\n        case \"timed-out\":\n          if (interrupt_buffer[0] !== 0) {\n            handleInterrupt();\n          }\n          break;\n        default:\n          throw new Error(\"Unreachable\");\n      }\n    }\n  }\n\n  *tasksIdsToWakeup(): Generator<number, void, void> {\n    let flag = Atomics.load(this.signal_buffer, 0);\n    for (let i = 0; i < 32; i++) {\n      let bit = 1 << i;\n      if (flag & bit) {\n        Atomics.and(this.signal_buffer, 0, ~bit);\n        let wokenTask = Atomics.exchange(this.signal_buffer, i + 1, 0);\n        yield wokenTask;\n      }\n    }\n  }\n\n  pollTasks(task?: SynclinkTask<any>): boolean {\n    let result = false;\n    if (!task && this.tasks.size < 1) {\n      return true;\n    }\n    for (let wokenTaskId of this.tasksIdsToWakeup()) {\n      console.log(\"poll task\", wokenTaskId, \"looking for\",task);\n      let wokenTask = this.tasks.get(wokenTaskId);\n      if (!wokenTask) {\n        throw new Error(`Assertion error: unknown taskId ${wokenTaskId}.`);\n      }\n      if (wokenTask!.poll()) {\n        console.log(\"completed task \", wokenTaskId, wokenTask, wokenTask._result);\n        this.tasks.delete(wokenTaskId);\n        if (wokenTask === task) {\n          result = true;\n        }\n      }\n    }\n    return result;\n  }\n\n  syncifyTask(task: SynclinkTask<any>): void {\n    while (true) {\n      if (this.pollTasks(task)) {\n        return;\n      }\n      if (task.endpoint._bypass) {\n        throw new Error(\"oops!\");\n      }\n      this.waitOnSignalBuffer();\n    }\n  }\n}\nexport let Syncifier = new _Syncifier();\n\n(async function syncifyPollLoop() {\n  while (true) {\n    if (Syncifier.pollTasks()) {\n      return;\n    }\n    await sleep(20);\n  }\n})();\n", "import {\n  Endpoint,\n  EventSource,\n  Message,\n  MessageType,\n  messageTypeSet,\n  PostMessageWithOrigin,\n  WireValue,\n  WireValueType,\n  wireValueTypeSet,\n  StoreKey,\n} from \"./protocol\";\n\nimport { requestResponseMessage } from \"./request_response\";\n\nimport { createEndpoint, Remote, releaseProxy } from \"./types\";\nimport { proxy } from \"./transfer_handlers\";\nimport {\n  fromWireValue,\n  toWireValue,\n  transfer,\n  throwMarker,\n  storeCreate,\n  storeGetValue,\n  storeDeleteKey,\n} from \"./transfer_handlers\";\n\nimport { SynclinkTask, syncResponse } from \"./task\";\n\nfunction innerMessageHandler(obj_arg: any, ep: Endpoint, message: Message) {\n  const { id, path, store_key } = {\n    path: [] as string[],\n    store_key: undefined,\n    ...message,\n  };\n  let obj;\n  if (store_key) {\n    obj = storeGetValue(ep, store_key);\n  } else {\n    obj = obj_arg;\n  }\n  if (obj_arg === undefined && store_key === undefined) {\n    console.warn(obj_arg, message);\n    throw new Error(\"Internal synclink error!\");\n  }\n  const argumentList = ((message as any).argumentList || []).map((v: any) => {\n    if (v.type === WireValueType.PROXY) {\n      return innerMessageHandler(obj_arg, ep, v.message);\n    } else {\n      return fromWireValue(ep, v);\n    }\n  });\n  const last = path.pop();\n  let parent = path.reduce((obj, prop) => obj[prop], obj);\n  const rawValue = last ? parent[last] : obj;\n  if (!last) {\n    parent = undefined;\n  }\n  if (rawValue === undefined) {\n    switch (message.type) {\n      case MessageType.GET:\n      case MessageType.SET:\n        break;\n      default:\n        console.warn(\"Undefined\", obj, path, last);\n        throw new Error(\"undefined!!\" + ` ${obj}, ${path}, ${last}`);\n    }\n  }\n  switch (message.type) {\n    case MessageType.GET:\n      {\n        return rawValue;\n      }\n      break;\n    case MessageType.SET:\n      {\n        parent[last!] = fromWireValue(ep, message.value);\n        return true;\n      }\n      break;\n    case MessageType.APPLY:\n      {\n        if (last) {\n          return parent[last].apply(parent, argumentList);\n        } else {\n          return rawValue.apply(parent, argumentList);\n        }\n      }\n      break;\n    case MessageType.CONSTRUCT:\n      {\n        const value = new rawValue(...argumentList);\n        return proxy(value);\n      }\n      break;\n    case MessageType.ENDPOINT:\n      {\n        const { port1, port2 } = new MessageChannel();\n        expose(obj, port2);\n        return transfer(port1, [port1]);\n      }\n      break;\n    case MessageType.RELEASE:\n      {\n        return undefined;\n      }\n      break;\n    case MessageType.DESTROY:\n      {\n        storeDeleteKey(ep, store_key!);\n        return undefined;\n      }\n      break;\n    default:\n      return undefined;\n  }\n}\n\nexport function expose(obj_arg: any, ep: Endpoint = globalThis as any) {\n  const wrap = false;\n  exposeInner(obj_arg, ep, wrap);\n}\n\nfunction exposeInner(\n  obj_arg: any,\n  ep: Endpoint = globalThis as any,\n  wrap: boolean,\n) {\n  storeCreate(ep);\n  ep.addEventListener(\"message\", async function callback(ev: MessageEvent) {\n    if (!ev || !ev.data) {\n      return;\n    }\n    if (!messageTypeSet.has(ev.data.type)) {\n      if (!wireValueTypeSet.has(ev.data.type) && !ev.data.data_buffer) {\n        console.warn(\"Internal error on message:\", ev.data);\n        throw new Error(\n          `Synclink Internal error: Expected message.type to either be a MessageType or a WireValueType, got '${ev.data.type}'`,\n        );\n      }\n      // It was a response.\n      // TODO: assert that there is a requestResponseMessage waiting for this id?\n      return;\n    }\n    const message = ev.data as Message;\n    const { id, type, store_key } = { store_key: undefined, ...message };\n    if (wrap && store_key === undefined) {\n      // TODO: What are these messages doing?\n      return;\n    }\n    const sync = ev.data.syncify;\n    let returnValue;\n    try {\n      returnValue = innerMessageHandler(obj_arg, ep, message);\n      if (returnValue && returnValue.then) {\n        if (sync && ep._bypass) {\n          throw new Error(\"Cannot use syncify with bypass on an async method\");\n        }\n        returnValue = await returnValue;\n      }\n    } catch (value) {\n      returnValue = { value, [throwMarker]: 0 };\n    }\n    const [wireValue, transferables] = toWireValue(ep, returnValue);\n    if (sync) {\n      syncResponse(ep, ev.data, wireValue);\n    } else {\n      ep.postMessage({ ...wireValue, id }, transferables);\n    }\n    if (type === MessageType.RELEASE) {\n      // detach and deactivate after sending release response above.\n      ep.removeEventListener(\"message\", callback as any);\n      closeEndPoint(ep);\n    }\n  } as any);\n  if (ep.start) {\n    ep.start();\n  }\n}\n\nfunction isMessagePort(endpoint: Endpoint): endpoint is MessagePort {\n  return endpoint.constructor.name === \"MessagePort\";\n}\n\nfunction closeEndPoint(endpoint: Endpoint) {\n  if (isMessagePort(endpoint)) endpoint.close();\n}\n\nexport function wrap<T>(ep: Endpoint, target?: any): Remote<T> {\n  const wrap = true;\n  exposeInner(undefined, ep, wrap);\n  return createProxy<T>(ep, { target }) as any;\n}\n\nfunction throwIfProxyReleased(isReleased: boolean) {\n  if (isReleased) {\n    throw new Error(\"Proxy has been released and is not usable\");\n  }\n}\n\nexport function createProxy<T>(\n  ep: Endpoint,\n  {\n    store_key = undefined,\n    path = [],\n    target = function () {},\n  }: {\n    store_key?: StoreKey;\n    path?: (string | number | symbol)[];\n    target?: object;\n  },\n): Remote<T> {\n  let isProxyReleased = false;\n  const proxy = new Proxy(target, {\n    get(_target, prop) {\n      throwIfProxyReleased(isProxyReleased);\n      switch (prop) {\n        case \"$$ep\":\n          return ep;\n        case Symbol.toStringTag:\n          return \"SynclinkProxy\";\n        case releaseProxy:\n          return () => {\n            return new SynclinkTask(\n              ep,\n              {\n                type: MessageType.RELEASE,\n                path: path.map((p) => p.toString()),\n              },\n              [],\n              () => {\n                closeEndPoint(ep);\n                isProxyReleased = true;\n              },\n            );\n          };\n        case \"__destroy__\":\n          if (!store_key) {\n            return () => {};\n          }\n          return () => {\n            return new SynclinkTask(\n              ep,\n              {\n                type: MessageType.DESTROY,\n                store_key,\n              },\n              [],\n              () => {\n                isProxyReleased = true;\n              },\n            );\n          };\n        case \"_as_message\":\n          return () => {\n            return {\n              type: MessageType.GET,\n              store_key,\n              path: path.map((p) => p.toString()),\n            };\n          };\n        case \"then\":\n        case \"schedule_async\":\n        case \"schedule_sync\":\n        case \"syncify\":\n          if (path.length === 0 && prop === \"then\") {\n            return { then: () => proxy };\n          }\n          let r = new SynclinkTask(\n            ep,\n            {\n              type: MessageType.GET,\n              store_key,\n              path: path.map((p) => p.toString()),\n            },\n            [],\n            undefined,\n          );\n          return r[prop].bind(r);\n        default:\n          return createProxy(ep, { store_key, path: [...path, prop] });\n      }\n    },\n    set(_target, prop, rawValue) {\n      throwIfProxyReleased(isProxyReleased);\n      // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\n      // boolean. To show good will, we return true asynchronously \u00AF\\_(\u30C4)_/\u00AF\n      const [value, transferables] = toWireValue(ep, rawValue);\n      return requestResponseMessage(\n        ep,\n        {\n          type: MessageType.SET,\n          store_key,\n          path: [...path, prop].map((p) => p.toString()),\n          value,\n        },\n        transferables,\n      ).then((v) => fromWireValue(ep, v)) as any;\n    },\n    apply(_target, _thisArg, rawArgumentList) {\n      throwIfProxyReleased(isProxyReleased);\n      const last = path[path.length - 1];\n      if ((last as any) === createEndpoint) {\n        return requestResponseMessage(ep, {\n          type: MessageType.ENDPOINT,\n        }).then((v) => fromWireValue(ep, v));\n      }\n      // We just pretend that `bind()` didn\u2019t happen.\n      if (last === \"bind\") {\n        return createProxy(ep, { store_key, path: path.slice(0, -1) });\n      }\n      if (last === \"apply\") {\n        // temporary hack...\n        rawArgumentList = rawArgumentList[1];\n        path = path.slice(0, -1);\n      }\n      const [argumentList, transferables] = processArguments(\n        ep,\n        rawArgumentList,\n      );\n      return new SynclinkTask(\n        ep,\n        {\n          type: MessageType.APPLY,\n          store_key,\n          path: path.map((p) => p.toString()),\n          argumentList,\n        },\n        transferables,\n        undefined,\n      );\n    },\n    construct(_target, rawArgumentList) {\n      throwIfProxyReleased(isProxyReleased);\n      const [argumentList, transferables] = processArguments(\n        ep,\n        rawArgumentList,\n      );\n      return requestResponseMessage(\n        ep,\n        {\n          type: MessageType.CONSTRUCT,\n          store_key,\n          path: path.map((p) => p.toString()),\n          argumentList,\n        },\n        transferables,\n      ).then((v) => fromWireValue(ep, v));\n    },\n    ownKeys(_target) {\n      return [];\n    },\n  });\n  return proxy as any;\n}\n\nfunction myFlat<T>(arr: (T | T[])[]): T[] {\n  return Array.prototype.concat.apply([], arr);\n}\n\nfunction processArguments(\n  ep: Endpoint,\n  argumentList: any[],\n): [WireValue[], Transferable[]] {\n  const processed = argumentList.map((v) => toWireValue(ep, v));\n  return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];\n}\n\nexport function windowEndpoint(\n  w: PostMessageWithOrigin,\n  context: EventSource = self,\n  targetOrigin = \"*\",\n): Endpoint {\n  return {\n    postMessage: (msg: any, transferables: Transferable[]) =>\n      w.postMessage(msg, targetOrigin, transferables),\n    addEventListener: context.addEventListener.bind(context),\n    removeEventListener: context.removeEventListener.bind(context),\n  };\n}\n", "class FakeMessagePort {\n  _otherPort: FakeMessagePort;\n  _handlers: ((msg: { data: any }) => void)[] = [];\n  _bypass: boolean = true;\n  start() {}\n  close() {}\n\n  constructor() {\n    this._otherPort = this;\n  }\n\n  addEventListener(event: string, handler: (msg: { data: any }) => void) {\n    if (event === \"message\") {\n      this._handlers.push(handler);\n    }\n  }\n\n  removeEventListener(event: string, handler: (msg: { data: any }) => void) {\n    if (event !== \"message\") {\n      return;\n    }\n    let idx = this._handlers.indexOf(handler);\n    if (idx >= 0) {\n      this._handlers.splice(idx, 1);\n    }\n  }\n\n  postMessage(message: any, transfer: Transferable[]) {\n    for (const h of this._otherPort._handlers) {\n      h({ data: message });\n    }\n  }\n}\n\nclass FakeMessageChannel {\n  port1: FakeMessagePort;\n  port2: FakeMessagePort;\n  constructor() {\n    this.port1 = new FakeMessagePort();\n    this.port2 = new FakeMessagePort();\n    this.port1._otherPort = this.port2;\n    this.port2._otherPort = this.port1;\n  }\n}\n\nlet FakeMessageChannel1 =\n  FakeMessageChannel as unknown as typeof MessageChannel;\n\nexport { FakeMessageChannel1 as FakeMessageChannel };\n", "import { Endpoint, WireValue, WireValueType, StoreKey } from \"./protocol\";\nimport { generateUUID } from \"./request_response\";\nimport { createProxy, expose, wrap } from \"./async_task\";\nimport { FakeMessageChannel } from \"./fake_message_channel\";\nimport { ProxyMarked, proxyMarker } from \"./types\";\n\nexport const throwMarker = Symbol(\"Synclink.thrown\");\n\nconst transferCache = new WeakMap<any, Transferable[]>();\nexport function transfer<T>(obj: T, transfers: Transferable[]): T {\n  transferCache.set(obj, transfers);\n  return obj;\n}\n\nexport const isObject = (val: unknown): val is object =>\n  (typeof val === \"object\" && val !== null) || typeof val === \"function\";\n\n/**\n * Customizes the serialization of certain values as determined by `canHandle()`.\n *\n * @template T The input type being handled by this transfer handler.\n * @template S The serialized type sent over the wire.\n */\nexport interface TransferHandler<T, S> {\n  /**\n   * Gets called for every value to determine whether this transfer handler\n   * should serialize the value, which includes checking that it is of the right\n   * type (but can perform checks beyond that as well).\n   */\n  canHandle(value: unknown): value is T;\n\n  /**\n   * Gets called with the value if `canHandle()` returned `true` to produce a\n   * value that can be sent in a message, consisting of structured-cloneable\n   * values and/or transferrable objects.\n   */\n  serialize(value: T): [S, Transferable[]];\n\n  /**\n   * Gets called to deserialize an incoming value that was serialized in the\n   * other thread with this transfer handler (known through the name it was\n   * registered under).\n   */\n  deserialize(value: S): T;\n}\n\n/**\n * Allows customizing the serialization of certain values.\n */\nexport const transferHandlers = new Map<\n  string,\n  TransferHandler<unknown, unknown>\n>();\n\nfunction isArrayBufferOrView(obj: any): boolean {\n  return (\n    ArrayBuffer.isView(obj) ||\n    Object.prototype.toString.call(obj) === \"[object ArrayBuffer]\"\n  );\n}\n\nfunction isPlain(val: any) {\n  return (\n    !val ||\n    typeof val === \"string\" ||\n    typeof val === \"boolean\" ||\n    typeof val === \"number\" ||\n    Array.isArray(val) ||\n    isArrayBufferOrView(val) ||\n    !val.constructor ||\n    (val.constructor === Object &&\n      Object.prototype.toString.call(val) === \"[object Object]\")\n  );\n}\n\nfunction isSerializable(obj: any, transfers: Transferable[] = []) {\n  if (transfers.includes(obj)) {\n    return true;\n  }\n  if (!isPlain(obj)) {\n    return false;\n  }\n  for (var property in obj) {\n    if (obj.hasOwnProperty(property)) {\n      if (!isPlain(obj[property])) {\n        return false;\n      }\n      if (typeof obj[property] == \"object\") {\n        if (!isSerializable(obj[property], transfers)) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}\n\ninterface ThrownValue {\n  [throwMarker]: unknown; // just needs to be present\n  value: unknown;\n}\ntype SerializedThrownValue =\n  | { isError: true; value: Error }\n  | { isError: false; value: unknown };\n\n/**\n * Internal transfer handler to handle thrown exceptions.\n */\nexport const throwTransferHandler: TransferHandler<\n  ThrownValue,\n  SerializedThrownValue\n> = {\n  canHandle: (value): value is ThrownValue =>\n    isObject(value) && throwMarker in value,\n  serialize({ value }) {\n    let serialized: SerializedThrownValue;\n    if (value instanceof Error) {\n      serialized = {\n        isError: true,\n        value: {\n          message: value.message,\n          name: value.name,\n          stack: value.stack,\n        },\n      };\n    } else {\n      serialized = { isError: false, value };\n    }\n    return [serialized, []];\n  },\n  deserialize(serialized) {\n    if (serialized.isError) {\n      throw Object.assign(\n        new Error(serialized.value.message),\n        serialized.value,\n      );\n    }\n    throw serialized.value;\n  },\n};\n\nexport function toWireValue(\n  ep: Endpoint,\n  value: any,\n): [WireValue, Transferable[]] {\n  if (value && value.$$ep === ep) {\n    return [\n      {\n        type: WireValueType.PROXY,\n        message: value._as_message(),\n      },\n      [],\n    ];\n  }\n  if (value && value.constructor && value.constructor.name === \"SynclinkTask\") {\n    return [\n      {\n        type: WireValueType.PROXY,\n        message: value.msg,\n      },\n      [],\n    ];\n  }\n  if (ep._bypass) {\n    proxyFakeMessagePort = true;\n  }\n  try {\n    for (const [name, handler] of transferHandlers) {\n      if (handler.canHandle(value)) {\n        const [serializedValue, transferables] = handler.serialize(value);\n        return [\n          {\n            type: WireValueType.HANDLER,\n            name,\n            value: serializedValue,\n          },\n          transferables,\n        ];\n      }\n    }\n  } finally {\n    proxyFakeMessagePort = false;\n  }\n  if (isSerializable(value, transferCache.get(value))) {\n    return [\n      {\n        type: WireValueType.RAW,\n        value,\n      },\n      transferCache.get(value) || [],\n    ];\n  }\n  let store_key = storeNewValue(ep, value);\n  return [\n    {\n      type: WireValueType.ID,\n      store_key,\n      endpoint_uuid: (ep as any)[endpointUUID],\n      ownkeys: Object.getOwnPropertyNames(value),\n    },\n    [],\n  ];\n}\n\nexport function fromWireValue(ep: Endpoint, value: WireValue): any {\n  switch (value.type) {\n    case WireValueType.HANDLER:\n      return transferHandlers.get(value.name)!.deserialize(value.value);\n    case WireValueType.RAW:\n      return value.value;\n    case WireValueType.ID:\n      let this_uuid = (ep as any)[endpointUUID];\n      if (this_uuid === value.endpoint_uuid) {\n        return storeGetValue(ep, value.store_key);\n      } else {\n        return createProxy(ep, { store_key: value.store_key });\n      }\n  }\n}\n\nconst proxyStore = Symbol(\"Synclink.proxyStore\");\nconst endpointUUID = Symbol(\"Synclink.endpointUUID\");\n\nexport function storeCreate(obj: any) {\n  if (proxyStore in obj) {\n    return;\n  }\n  obj[proxyStore] = { objects: new Map(), counter: new Uint32Array([1]) };\n  obj[endpointUUID] = generateUUID();\n}\n\nexport function storeGetValue(obj: any, key: StoreKey) {\n  return obj[proxyStore].objects.get(key);\n}\n\nexport function storeNewValue(obj: any, value: any): StoreKey {\n  if (!(proxyStore in obj)) {\n    storeCreate(obj);\n  }\n  let { objects, counter } = obj[proxyStore];\n  while (objects.has(counter[0])) {\n    // Increment by two here (and below) because even integers are reserved\n    // for singleton constants\n    counter[0] += 2;\n  }\n  let key = counter[0];\n  counter[0] += 2;\n  objects.set(key, value);\n  return key;\n}\n\nexport function storeDeleteKey(obj: any, key: StoreKey): any {\n  let { objects } = obj[proxyStore];\n  objects.delete(key);\n  console.log(\"deleted\", key, objects);\n}\n\nexport function proxy<T>(obj: T): T & ProxyMarked {\n  return Object.assign(obj as any, { [proxyMarker]: true }) as any;\n}\n\nlet proxyFakeMessagePort = false;\n\n/**\n * Internal transfer handle to handle objects marked to proxy.\n */\nexport const proxyTransferHandler: TransferHandler<object, MessagePort> = {\n  canHandle: (val): val is ProxyMarked =>\n    isObject(val) && (val as ProxyMarked)[proxyMarker],\n  serialize(obj) {\n    const { port1, port2 } = (\n      proxyFakeMessagePort ? new FakeMessageChannel() : new MessageChannel()\n    ) as MessageChannel;\n    expose(obj, port1);\n    return [port2, [port2]];\n  },\n  deserialize(port) {\n    port.start();\n    return wrap(port);\n  },\n};\n", "/**\n * Copyright 2019 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport { Endpoint } from \"./protocol\";\n\nexport {\n  TransferHandler,\n  transferHandlers,\n  transfer,\n} from \"./transfer_handlers\";\n\nexport {\n  ProxyOrClone,\n  UnproxyOrClone,\n  RemoteObject,\n  LocalObject,\n  ProxyMethods,\n  Remote,\n  Local,\n  createEndpoint,\n  releaseProxy,\n  proxyMarker,\n  ProxyMarked,\n} from \"./types\";\n\nexport { expose, wrap, windowEndpoint } from \"./async_task\";\n\nexport { interrupt_buffer, setInterruptHandler, Syncifier } from \"./task\";\n\nimport {\n  transferHandlers,\n  throwTransferHandler,\n  proxyTransferHandler,\n} from \"./transfer_handlers\";\nexport { FakeMessageChannel } from \"./fake_message_channel\";\n\nexport { proxy } from \"./transfer_handlers\";\n\ntransferHandlers.set(\"throw\", throwTransferHandler);\ntransferHandlers.set(\"proxy\", proxyTransferHandler);\n\ntransferHandlers.set(\"headers\", {\n  canHandle(value: unknown): value is Headers {\n    return Object.prototype.toString.call(value) === \"[object Headers]\";\n  },\n  serialize(value: Headers): [[string, string][], Transferable[]] {\n    return [Array.from(value as any), []];\n  },\n  deserialize(value: [string, string][]): Headers {\n    return new Headers(value);\n  },\n});\n"],
  "mappings": "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",
  "names": ["wireValueTypeRecord", "wireValueTypeSet", "messageTypeRecord", "messageTypeSet", "requestResponseMessageInner", "ep", "id", "generateUUID", "resolve", "__name", "l", "ev", "requestResponseMessage", "msg", "transfers", "promise", "__spreadValues", "UUID_LENGTH", "randomSegment", "result", "pad", "_", "createEndpoint", "releaseProxy", "proxyMarker", "temp", "shared_array_buffer_default", "decoder", "encoder", "SZ_BUF_SIZE_IDX", "SZ_BUF_FITS_IDX", "SZ_BUF_DOESNT_FIT", "sleep", "ms", "resolve", "__name", "SynclinkTask", "endpoint", "msg", "transfers", "extra", "reject", "value", "reason", "onfulfilled", "onrejected", "__async", "onfinally", "Syncifier", "done", "fromWireValue", "e", "size_buffer", "shared_array_buffer_default", "signal_buffer", "taskId", "data_buffer", "acquireDataBuffer", "UUID_LENGTH", "__spreadProps", "__spreadValues", "id", "releaseDataBuffer", "size", "result", "requestResponseMessage", "signalRequester", "index", "sleepTime", "syncResponse", "returnValue", "bytes", "fits", "uuid", "data_promise", "requestResponseMessageInner", "dataBuffers", "powerof2", "__pow", "buffer", "interrupt_buffer", "handleInterrupt", "setInterruptHandler", "handler", "_Syncifier", "task", "timeout", "flag", "i", "bit", "wokenTaskId", "wokenTask", "innerMessageHandler", "obj_arg", "ep", "message", "id", "path", "store_key", "__spreadValues", "obj", "storeGetValue", "argumentList", "v", "fromWireValue", "last", "parent", "prop", "rawValue", "value", "proxy", "port1", "port2", "expose", "transfer", "storeDeleteKey", "__name", "exposeInner", "wrap", "storeCreate", "callback", "ev", "__async", "messageTypeSet", "wireValueTypeSet", "type", "sync", "returnValue", "throwMarker", "wireValue", "transferables", "toWireValue", "syncResponse", "__spreadProps", "closeEndPoint", "isMessagePort", "endpoint", "target", "createProxy", "throwIfProxyReleased", "isReleased", "isProxyReleased", "_target", "releaseProxy", "SynclinkTask", "p", "r", "requestResponseMessage", "_thisArg", "rawArgumentList", "createEndpoint", "processArguments", "myFlat", "arr", "processed", "windowEndpoint", "w", "context", "targetOrigin", "msg", "FakeMessagePort", "event", "handler", "idx", "message", "transfer", "h", "__name", "FakeMessageChannel", "FakeMessageChannel1", "throwMarker", "transferCache", "transfer", "obj", "transfers", "__name", "isObject", "val", "transferHandlers", "isArrayBufferOrView", "isPlain", "isSerializable", "property", "throwTransferHandler", "value", "serialized", "toWireValue", "ep", "proxyFakeMessagePort", "name", "handler", "serializedValue", "transferables", "store_key", "storeNewValue", "endpointUUID", "fromWireValue", "storeGetValue", "createProxy", "proxyStore", "storeCreate", "generateUUID", "key", "objects", "counter", "storeDeleteKey", "proxy", "proxyMarker", "proxyTransferHandler", "port1", "port2", "FakeMessageChannel1", "expose", "port", "wrap", "transferHandlers", "throwTransferHandler", "proxyTransferHandler", "value"]
}
