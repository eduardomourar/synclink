{
  "version": 3,
  "sources": ["../../src/synclink.ts", "../../src/protocol.ts", "../../src/request_response.ts", "../../src/types.ts", "../../src/shared_array_buffer.ts", "../../src/task.ts", "../../src/async_task.ts", "../../src/fake_message_channel.ts", "../../src/transfer_handlers.ts"],
  "sourcesContent": ["/**\n * Copyright 2019 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport { Endpoint } from \"./protocol\";\n\nexport {\n  TransferHandler,\n  transferHandlers,\n  transfer,\n} from \"./transfer_handlers\";\n\nexport {\n  ProxyOrClone,\n  UnproxyOrClone,\n  RemoteObject,\n  LocalObject,\n  ProxyMethods,\n  Remote,\n  Local,\n  createEndpoint,\n  releaseProxy,\n  proxyMarker,\n  ProxyMarked,\n} from \"./types\";\n\nexport { expose, wrap, windowEndpoint } from \"./async_task\";\n\nexport { interrupt_buffer, setInterruptHandler, Syncifier } from \"./task\";\n\nimport {\n  transferHandlers,\n  throwTransferHandler,\n  proxyTransferHandler,\n} from \"./transfer_handlers\";\nexport { FakeMessageChannel } from \"./fake_message_channel\";\n\nexport { proxy } from \"./transfer_handlers\";\n\ntransferHandlers.set(\"throw\", throwTransferHandler);\ntransferHandlers.set(\"proxy\", proxyTransferHandler);\n\ntransferHandlers.set(\"headers\", {\n  canHandle(value: unknown): value is Headers {\n    return Object.prototype.toString.call(value) === \"[object Headers]\";\n  },\n  serialize(value: Headers): [[string, string][], Transferable[]] {\n    return [Array.from(value as any), []];\n  },\n  deserialize(value: [string, string][]): Headers {\n    return new Headers(value);\n  },\n});\n", "/**\n * Copyright 2019 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport interface EventSource {\n  addEventListener(\n    type: string,\n    listener: EventListenerOrEventListenerObject,\n    options?: {},\n  ): void;\n\n  removeEventListener(\n    type: string,\n    listener: EventListenerOrEventListenerObject,\n    options?: {},\n  ): void;\n}\n\nexport interface PostMessageWithOrigin {\n  postMessage(\n    message: any,\n    targetOrigin: string,\n    transfer?: Transferable[],\n  ): void;\n}\n\nexport interface Endpoint extends EventSource {\n  postMessage(message: any, transfer?: Transferable[]): void;\n  start?: () => void;\n  _bypass?: boolean;\n}\n\nexport const enum WireValueType {\n  RAW = \"RAW\",\n  PROXY = \"PROXY\",\n  THROW = \"THROW\",\n  HANDLER = \"HANDLER\",\n  ID = \"ID\",\n}\n\n// It's not possible to automatically generate a set of values from a const enum\n// https://github.com/microsoft/TypeScript/issues/21391\n\n// This dance allows us to hand write the value set in a type safe way -- if a\n// case is added to or removed from the enum without updating the value set,\n// it's a type error.\nconst wireValueTypeRecord: Record<keyof typeof WireValueType, number> = {\n  [WireValueType.RAW]: 1,\n  [WireValueType.PROXY]: 1,\n  [WireValueType.THROW]: 1,\n  [WireValueType.HANDLER]: 1,\n  [WireValueType.ID]: 1,\n};\nexport const wireValueTypeSet = new Set(\n  Object.keys(wireValueTypeRecord),\n) as Set<keyof typeof WireValueType>;\n\nexport interface RawWireValue {\n  id?: string;\n  type: WireValueType.RAW;\n  value: {};\n}\n\nexport interface HandlerWireValue {\n  id?: string;\n  type: WireValueType.HANDLER;\n  name: string;\n  value: unknown;\n}\n\nexport interface IdWireValue {\n  id?: string;\n  type: WireValueType.ID;\n  ownkeys: string[];\n  endpoint_uuid: string;\n  store_key: number;\n}\n\nexport interface ProxyWireValue {\n  id?: string;\n  type: WireValueType.PROXY;\n  message: Message;\n}\n\nexport type WireValue =\n  | RawWireValue\n  | HandlerWireValue\n  | IdWireValue\n  | ProxyWireValue;\n\nexport type MessageID = string;\n\nexport type StoreKey = number;\n\nexport const enum MessageType {\n  GET = \"GET\",\n  SET = \"SET\",\n  APPLY = \"APPLY\",\n  CONSTRUCT = \"CONSTRUCT\",\n  ENDPOINT = \"ENDPOINT\",\n  RELEASE = \"RELEASE\",\n  DESTROY = \"DESTROY\",\n}\n\n// It's not possible to automatically generate a set of values from a const enum\n// https://github.com/microsoft/TypeScript/issues/21391\n\n// This dance allows us to hand write the value set in a type safe way -- if a\n// case is added to or removed from the enum without updating the value set,\n// it's a type error.\nconst messageTypeRecord: Record<keyof typeof MessageType, number> = {\n  [MessageType.SET]: 1,\n  [MessageType.GET]: 1,\n  [MessageType.APPLY]: 1,\n  [MessageType.CONSTRUCT]: 1,\n  [MessageType.ENDPOINT]: 1,\n  [MessageType.RELEASE]: 1,\n  [MessageType.DESTROY]: 1,\n};\nexport const messageTypeSet = new Set(Object.keys(messageTypeRecord)) as Set<\n  keyof typeof MessageType\n>;\n\nexport interface GetMessage {\n  id?: MessageID;\n  store_key?: StoreKey;\n  type: MessageType.GET;\n  path: string[];\n}\n\nexport interface SetMessage {\n  id?: MessageID;\n  type: MessageType.SET;\n  store_key?: StoreKey;\n  path: string[];\n  value: WireValue;\n}\n\nexport interface ApplyMessage {\n  id?: MessageID;\n  type: MessageType.APPLY;\n  store_key?: StoreKey;\n  path: string[];\n  argumentList: WireValue[];\n}\n\nexport interface ConstructMessage {\n  id?: MessageID;\n  type: MessageType.CONSTRUCT;\n  store_key?: StoreKey;\n  path: string[];\n  argumentList: WireValue[];\n}\n\nexport interface EndpointMessage {\n  id?: MessageID;\n  type: MessageType.ENDPOINT;\n}\n\nexport interface ReleaseMessage {\n  id?: MessageID;\n  type: MessageType.RELEASE;\n  path: string[];\n}\n\nexport interface DestroyMessage {\n  id?: MessageID;\n  type: MessageType.DESTROY;\n  store_key: StoreKey;\n}\n\nexport type Message =\n  | GetMessage\n  | SetMessage\n  | ApplyMessage\n  | ConstructMessage\n  | EndpointMessage\n  | ReleaseMessage\n  | DestroyMessage;\n\ntype StaticAssert<T extends true> = T;\ntype AreDisjoint<S, T> = S & T extends never ? true : false;\ntype AssertMessageTypeAndWireTypeAreDisjoint = StaticAssert<\n  AreDisjoint<WireValueType, MessageType>\n>;\n", "import { Endpoint, Message, WireValue } from \"./protocol\";\nexport { requestResponseMessageInner, requestResponseMessage };\n\nfunction requestResponseMessageInner(\n  ep: Endpoint,\n): [string, Promise<WireValue>] {\n  const id = generateUUID();\n  return [\n    id,\n    new Promise((resolve) => {\n      ep.addEventListener(\"message\", function l(ev: MessageEvent) {\n        if (!ev.data || !ev.data.id || ev.data.id !== id) {\n          return;\n        }\n        ep.removeEventListener(\"message\", l as any);\n        resolve(ev.data);\n      } as any);\n      if (ep.start) {\n        ep.start();\n      }\n    }),\n  ];\n}\n\nfunction requestResponseMessage(\n  ep: Endpoint,\n  msg: Message,\n  transfers?: Transferable[],\n): Promise<WireValue> {\n  let [id, promise] = requestResponseMessageInner(ep);\n  ep.postMessage({ id, ...msg }, transfers);\n  return promise;\n}\n\nexport let UUID_LENGTH = 63;\n\nfunction randomSegment() {\n  let result = Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16);\n  let pad = 15 - result.length;\n  if (pad > 0) {\n    result = Array.from({ length: pad }, (_) => 0).join(\"\") + result;\n  }\n  return result;\n}\n\nexport function generateUUID(): string {\n  let result = Array.from({ length: 4 }, randomSegment).join(\"-\");\n  if (result.length !== UUID_LENGTH) {\n    throw new Error(\"synclink internal error: UUID has the wrong length\");\n  }\n  return result;\n}\n", "import type { SynclinkTask } from \"./task\";\n\nexport const createEndpoint = Symbol(\"Synclink.endpoint\");\nexport const releaseProxy = Symbol(\"Synclink.releaseProxy\");\nexport const proxyMarker = Symbol(\"Synclink.proxy\");\n\n/**\n * Interface of values that were marked to be proxied with `synclink.proxy()`.\n * Can also be implemented by classes.\n */\nexport interface ProxyMarked {\n  [proxyMarker]: true;\n}\n\n/**\n * Takes a type and wraps it in a Promise, if it not already is one.\n * This is to avoid `Promise<Promise<T>>`.\n *\n * This is the inverse of `Unpromisify<T>`.\n */\ntype Promisify<T> = T extends Promise<unknown> ? T : Promise<T>;\n/**\n * Takes a type that may be Promise and unwraps the Promise type.\n * If `P` is not a Promise, it returns `P`.\n *\n * This is the inverse of `Promisify<T>`.\n */\ntype Unpromisify<P> = P extends Promise<infer T> ? T : P;\n\n/**\n * Takes the raw type of a remote property and returns the type that is visible to the local thread on the proxy.\n *\n * Note: This needs to be its own type alias, otherwise it will not distribute over unions.\n * See https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#distributive-conditional-types\n */\ntype RemoteProperty<T> =\n  // If the value is a method, synclink will proxy it automatically.\n  // Objects are only proxied if they are marked to be proxied.\n  // Otherwise, the property is converted to a Promise that resolves the cloned value.\n  T extends Function | ProxyMarked ? Remote<T> : SynclinkTask<T>;\n\n/**\n * Takes the raw type of a property as a remote thread would see it through a proxy (e.g. when passed in as a function\n * argument) and returns the type that the local thread has to supply.\n *\n * This is the inverse of `RemoteProperty<T>`.\n *\n * Note: This needs to be its own type alias, otherwise it will not distribute over unions. See\n * https://www.typescriptlang.org/docs/handbook/advanced-types.html#distributive-conditional-types\n */\ntype LocalProperty<T> = T extends Function | ProxyMarked ? Local<T> : UnTask<T>;\n\n/**\n * Proxies `T` if it is a `ProxyMarked`, clones it otherwise (as handled by structured cloning and transfer handlers).\n */\nexport type ProxyOrClone<T> = T extends ProxyMarked ? Remote<T> : T;\n/**\n * Inverse of `ProxyOrClone<T>`.\n */\nexport type UnproxyOrClone<T> = T extends RemoteObject<ProxyMarked>\n  ? Local<T>\n  : T;\n\n/**\n * Takes the raw type of a remote object in the other thread and returns the type as it is visible to the local thread\n * when proxied with `Synclink.proxy()`.\n *\n * This does not handle call signatures, which is handled by the more general `Remote<T>` type.\n *\n * @template T The raw type of a remote object as seen in the other thread.\n */\nexport type RemoteObject<T> = { [P in keyof T]: RemoteProperty<T[P]> };\n/**\n * Takes the type of an object as a remote thread would see it through a proxy (e.g. when passed in as a function\n * argument) and returns the type that the local thread has to supply.\n *\n * This does not handle call signatures, which is handled by the more general `Local<T>` type.\n *\n * This is the inverse of `RemoteObject<T>`.\n *\n * @template T The type of a proxied object.\n */\nexport type LocalObject<T> = { [P in keyof T]: LocalProperty<T[P]> };\n\n/**\n * Additional special synclink methods available on each proxy returned by `Synclink.wrap()`.\n */\nexport interface ProxyMethods {\n  [createEndpoint]: () => Promise<MessagePort>;\n  [releaseProxy]: () => SynclinkTask<void>;\n}\n\ntype UnTask<T> = T extends SynclinkTask<infer S> ? S : T;\ntype MaybePromise<T> = Promise<T> | T;\n\n/**\n * Takes the raw type of a remote object, function or class in the other thread and returns the type as it is visible to\n * the local thread from the proxy return value of `Synclink.wrap()` or `Synclink.proxy()`.\n */\nexport type Remote<T> =\n  // Handle properties\n  RemoteObject<T> &\n    // Handle call signature (if present)\n    (T extends (...args: infer TArguments) => infer TReturn\n      ? (\n          ...args: { [I in keyof TArguments]: UnproxyOrClone<TArguments[I]> }\n        ) => SynclinkTask<ProxyOrClone<Unpromisify<TReturn>>>\n      : unknown) &\n    // Handle construct signature (if present)\n    // The return of construct signatures is always proxied (whether marked or not)\n    (T extends { new (...args: infer TArguments): infer TInstance }\n      ? {\n          new (\n            ...args: {\n              [I in keyof TArguments]: UnproxyOrClone<TArguments[I]>;\n            }\n          ): SynclinkTask<Remote<TInstance>>;\n        }\n      : unknown) &\n    // Include additional special synclink methods available on the proxy.\n    ProxyMethods;\n\n/**\n * Takes the raw type of a remote object, function or class as a remote thread would see it through a proxy (e.g. when\n * passed in as a function argument) and returns the type the local thread has to supply.\n *\n * This is the inverse of `Remote<T>`. It takes a `Remote<T>` and returns its original input `T`.\n */\nexport type Local<T> =\n  // Omit the special proxy methods (they don't need to be supplied, synclink adds them)\n  Omit<LocalObject<T>, keyof ProxyMethods> &\n    // Handle call signatures (if present)\n    (T extends (...args: infer TArguments) => infer TReturn\n      ? (\n          ...args: { [I in keyof TArguments]: ProxyOrClone<TArguments[I]> }\n        ) => // The raw function could either be sync or async, but is always proxied automatically\n        MaybePromise<UnproxyOrClone<UnTask<TReturn>>>\n      : unknown) &\n    // Handle construct signature (if present)\n    // The return of construct signatures is always proxied (whether marked or not)\n    (T extends { new (...args: infer TArguments): infer TInstance }\n      ? {\n          new (\n            ...args: {\n              [I in keyof TArguments]: ProxyOrClone<TArguments[I]>;\n            }\n          ): // The raw constructor could either be sync or async, but is always proxied automatically\n          MaybePromise<Local<UnTask<TInstance>>>;\n        }\n      : unknown);\n", "let temp: typeof ArrayBuffer | typeof SharedArrayBuffer;\nif (typeof SharedArrayBuffer === \"undefined\") {\n  temp = ArrayBuffer;\n} else {\n  temp = SharedArrayBuffer;\n}\nexport default temp;\n", "import { Endpoint, Message, WireValue } from \"./protocol\";\n\nimport {\n  requestResponseMessage,\n  requestResponseMessageInner,\n  UUID_LENGTH,\n} from \"./request_response\";\nimport SharedArrayBuffer from \"./shared_array_buffer\";\n\nimport { fromWireValue } from \"./transfer_handlers\";\n\nlet decoder = new TextDecoder(\"utf-8\");\nlet encoder = new TextEncoder();\n\nconst SZ_BUF_SIZE_IDX = 0;\nconst SZ_BUF_FITS_IDX = 1;\n\nconst SZ_BUF_DOESNT_FIT = 0;\n\nfunction sleep(ms: number) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\ntype ResolvedSynclinkTask<T> = SynclinkTask<T> & { _result: T };\n\n/**\n * This is a \"syncifiable\" promise. It consists of a task to be dispatched on\n * another thread. It can be dispatched asynchronously (the easy way) or\n * synchronously (the harder way). Either way, this promise does not start out\n * as scheduled, you\n */\nexport class SynclinkTask<T> {\n  endpoint: Endpoint;\n  msg: Message;\n  extra: () => void;\n  transfers: Transferable[];\n\n  mode?: \"sync\" | \"async\";\n\n  _resolved: boolean;\n  _result?: T;\n  _exception?: any;\n\n  // Async only\n  _promise: Promise<any>;\n  _resolve!: (value: any) => void;\n  _reject!: (value: any) => void;\n\n  // sync only\n  taskId?: number;\n  _sync_gen?: Generator<undefined, any, undefined>;\n  size_buffer?: Int32Array;\n  signal_buffer?: Int32Array;\n\n  constructor(\n    endpoint: Endpoint,\n    msg: Message,\n    transfers: Transferable[] = [],\n    extra: () => void = () => {},\n  ) {\n    this.endpoint = endpoint;\n    this.msg = msg;\n    this.extra = extra;\n    this.transfers = transfers;\n    this._resolved = false;\n    this._promise = new Promise((resolve, reject) => {\n      this._resolve = resolve;\n      this._reject = reject;\n    });\n  }\n\n  schedule_async(): this {\n    if (this.mode === \"async\") {\n      // already scheduled\n      return this;\n    }\n    if (this.mode === \"sync\") {\n      throw new Error(\"Already synchronously scheduled\");\n    }\n    this.mode = \"async\";\n    this.do_async().then(\n      (value) => {\n        // console.log(\"resolving\", this.taskId, \"value\", value);\n        this._resolved = true;\n        this._result = value;\n        this._resolve(value);\n      },\n      (reason) => {\n        this._exception = reason;\n        this._reject(reason);\n      },\n    );\n    return this;\n  }\n\n  async then<S>(\n    onfulfilled: (value: T) => S,\n    onrejected: (reason: any) => S,\n  ): Promise<S> {\n    this.schedule_async();\n    return this._promise.then(onfulfilled, onrejected);\n  }\n\n  catch<S>(onrejected: (reason: any) => S): Promise<S> {\n    this.schedule_async();\n    return this._promise.catch(onrejected);\n  }\n\n  finally(onfinally: () => void): Promise<T> {\n    this.schedule_async();\n    return this._promise.finally(onfinally);\n  }\n\n  schedule_sync(): this {\n    if (this.mode === \"sync\") {\n      // already scheduled\n      return this;\n    }\n    if (this.mode === \"async\") {\n      throw new Error(\"Already asynchronously scheduled\");\n    }\n    this.mode = \"sync\";\n    Syncifier.scheduleTask(this);\n    this._sync_gen = this.do_sync();\n    this._sync_gen.next();\n    return this;\n  }\n\n  isResolved(): this is ResolvedSynclinkTask<T> {\n    return this._resolved;\n  }\n\n  poll(): boolean {\n    if (this.mode != \"sync\") {\n      throw new Error(\"Task not synchronously scheduled\");\n    }\n    let { done, value } = this._sync_gen!.next();\n    if (!done) {\n      return false;\n    }\n    try {\n      this._resolved = true;\n      this._result = fromWireValue(this.endpoint, value);\n    } catch (e) {\n      console.warn(\"synclink exception:\", e);\n      this._exception = e;\n    }\n    return true;\n  }\n\n  *do_sync(): Generator<undefined, string, undefined> {\n    // just use syncRequest.\n    let { endpoint, msg, transfers } = this;\n    let size_buffer = new Int32Array(new SharedArrayBuffer(8));\n    let signal_buffer = this.signal_buffer!;\n    let taskId = this.taskId;\n    // Ensure status is cleared. We will notify\n    let data_buffer = acquireDataBuffer(UUID_LENGTH);\n    // console.log(\"===requesting\", taskId);\n    endpoint.postMessage(\n      {\n        ...msg,\n        size_buffer,\n        data_buffer,\n        signal_buffer,\n        taskId,\n        syncify: true,\n      },\n      transfers,\n    );\n    yield;\n    if (Atomics.load(size_buffer, SZ_BUF_FITS_IDX) === SZ_BUF_DOESNT_FIT) {\n      // There wasn't enough space, make a bigger data_buffer.\n      // First read uuid for response out of current data_buffer\n      const id = decoder.decode(data_buffer.slice(0, UUID_LENGTH));\n      releaseDataBuffer(data_buffer);\n      const size = Atomics.load(size_buffer, SZ_BUF_SIZE_IDX);\n      data_buffer = acquireDataBuffer(size);\n      // console.log(\"===bigger data buffer\", taskId);\n      endpoint.postMessage({ id, data_buffer });\n      yield;\n    }\n    const size = Atomics.load(size_buffer, SZ_BUF_SIZE_IDX);\n    // console.log(\"===completing\", taskId);\n    return JSON.parse(decoder.decode(data_buffer.slice(0, size)));\n  }\n\n  async do_async(): Promise<T> {\n    let result = await requestResponseMessage(\n      this.endpoint,\n      this.msg,\n      this.transfers,\n    );\n    this.extra();\n    return fromWireValue(this.endpoint, result);\n  }\n\n  get result(): T {\n    if (this._exception) {\n      throw this._exception;\n    }\n    if (this.isResolved()) {\n      return this._result;\n    }\n    throw new Error(\"Not ready.\");\n  }\n\n  syncify(): T {\n    this.schedule_sync();\n    Syncifier.syncifyTask(this);\n    return this.result;\n  }\n}\n\nasync function signalRequester(\n  signal_buffer: Uint32Array,\n  taskId: number,\n): Promise<void> {\n  let index = (taskId >> 1) % 32;\n  let sleepTime = 1;\n  while (Atomics.compareExchange(signal_buffer, index + 1, 0, taskId) !== 0) {\n    // No Atomics.asyncWait except on Chrome =(\n    await sleep(sleepTime);\n    if (sleepTime < 32) {\n      // exponential backoff\n      sleepTime *= 2;\n    }\n  }\n  Atomics.or(signal_buffer, 0, 1 << index);\n  // @ts-ignore\n  Atomics.notify(signal_buffer, 0);\n}\n\n/**\n * Respond to a blocking request. Most of the work has already been done in\n * asynclink, we are just responsible here for getting the return value back to\n * the requester through this slightly convoluted Atomics protocol.\n *\n * @param endpoint A message port to receive messages from. Other thread is\n *        blocked, so we can't send messages back.\n * @param msg The message that was received. We will use it to read out the\n *        buffers to write the answer into. NOTE: requester owns buffers.\n * @param returnValue The value we want to send back to the requester. We have\n *        to encode it into data_buffer.\n */\nexport async function syncResponse(\n  endpoint: Endpoint,\n  msg: any,\n  returnValue: WireValue,\n): Promise<void> {\n  try {\n    let { size_buffer, data_buffer, signal_buffer, taskId } = msg;\n    // console.warn(msg);\n    let bytes = encoder.encode(JSON.stringify(returnValue));\n    let fits = bytes.length <= data_buffer.length;\n    Atomics.store(size_buffer, SZ_BUF_SIZE_IDX, bytes.length);\n    Atomics.store(size_buffer, SZ_BUF_FITS_IDX, +fits);\n    if (!fits) {\n      // console.log(\"      need larger buffer\", taskId)\n      // Request larger buffer\n      let [uuid, data_promise] = requestResponseMessageInner(endpoint);\n      // Write UUID into data_buffer so syncRequest knows where to respond to.\n      data_buffer.set(encoder.encode(uuid));\n      await signalRequester(signal_buffer, taskId);\n      // Wait for response with new bigger data_buffer\n      data_buffer = ((await data_promise) as any).data_buffer;\n    }\n    // Encode result into data_buffer\n    data_buffer.set(bytes);\n    Atomics.store(size_buffer, SZ_BUF_FITS_IDX, +true);\n    // @ts-ignore\n    // console.log(\"       signaling completion\", taskId)\n    await signalRequester(signal_buffer, taskId);\n  } catch (e) {\n    console.warn(e);\n  }\n}\n\nlet dataBuffers: Uint8Array[][] = [];\n\nfunction acquireDataBuffer(size: number): Uint8Array {\n  let powerof2 = Math.ceil(Math.log2(size));\n  if (!dataBuffers[powerof2]) {\n    dataBuffers[powerof2] = [];\n  }\n  let result = dataBuffers[powerof2].pop();\n  if (result) {\n    result.fill(0);\n    return result;\n  }\n  return new Uint8Array(new SharedArrayBuffer(2 ** powerof2));\n}\n\nfunction releaseDataBuffer(buffer: Uint8Array) {\n  let powerof2 = Math.ceil(Math.log2(buffer.byteLength));\n  dataBuffers[powerof2].push(buffer);\n}\n\n/**\n * Another thread can set this to a nonzero value to request an interrupt.\n */\nexport let interrupt_buffer = new Int32Array(new SharedArrayBuffer(4));\n\nlet handleInterrupt = () => {\n  interrupt_buffer[0] = 0;\n  throw new Error(\"Interrupted!\");\n};\n\n/**\n * Sets the interrupt handler. This is called when the computation is\n * interrupted. Should zero the interrupt buffer and throw an exception.\n * @param handler\n */\nexport function setInterruptHandler(handler: () => never) {\n  handleInterrupt = handler;\n}\n\nclass _Syncifier {\n  nextTaskId: Int32Array;\n  signal_buffer: Int32Array;\n  tasks: Map<number, SynclinkTask<any>>;\n  constructor() {\n    this.nextTaskId = new Int32Array([1]);\n    this.signal_buffer = new Int32Array(new SharedArrayBuffer(32 * 4 + 4));\n    this.tasks = new Map();\n  }\n\n  scheduleTask(task: SynclinkTask<any>): void {\n    task.taskId = this.nextTaskId[0];\n    this.nextTaskId[0] += 2;\n    task.signal_buffer = this.signal_buffer;\n    this.tasks.set(task.taskId, task);\n  }\n\n  waitOnSignalBuffer(): void {\n    console.log(\"waiting on signal buffer\");\n    const timeout = 50;\n    while (true) {\n      const status = Atomics.wait(this.signal_buffer, 0, 0, timeout);\n      switch (status) {\n        case \"ok\":\n        case \"not-equal\":\n          console.log(\"finished waiting on signal buffer\");\n          return;\n        case \"timed-out\":\n          if (interrupt_buffer[0] !== 0) {\n            handleInterrupt();\n          }\n          break;\n        default:\n          throw new Error(\"Unreachable\");\n      }\n    }\n  }\n\n  *tasksIdsToWakeup(): Generator<number, void, void> {\n    let flag = Atomics.load(this.signal_buffer, 0);\n    for (let i = 0; i < 32; i++) {\n      let bit = 1 << i;\n      if (flag & bit) {\n        Atomics.and(this.signal_buffer, 0, ~bit);\n        let wokenTask = Atomics.exchange(this.signal_buffer, i + 1, 0);\n        yield wokenTask;\n      }\n    }\n  }\n\n  pollTasks(task?: SynclinkTask<any>): boolean {\n    let result = false;\n    if (!task && this.tasks.size < 1) {\n      return true;\n    }\n    for (let wokenTaskId of this.tasksIdsToWakeup()) {\n      console.log(\"poll task\", wokenTaskId, \"looking for\",task);\n      let wokenTask = this.tasks.get(wokenTaskId);\n      if (!wokenTask) {\n        throw new Error(`Assertion error: unknown taskId ${wokenTaskId}.`);\n      }\n      if (wokenTask!.poll()) {\n        console.log(\"completed task \", wokenTaskId, wokenTask, wokenTask._result);\n        this.tasks.delete(wokenTaskId);\n        if (wokenTask === task) {\n          result = true;\n        }\n      }\n    }\n    return result;\n  }\n\n  syncifyTask(task: SynclinkTask<any>): void {\n    while (true) {\n      if (this.pollTasks(task)) {\n        return;\n      }\n      if (task.endpoint._bypass) {\n        throw new Error(\"oops!\");\n      }\n      this.waitOnSignalBuffer();\n    }\n  }\n}\nexport let Syncifier = new _Syncifier();\n\n(async function syncifyPollLoop() {\n  while (true) {\n    if (Syncifier.pollTasks()) {\n      return;\n    }\n    await sleep(20);\n  }\n})();\n", "import {\n  Endpoint,\n  EventSource,\n  Message,\n  MessageType,\n  messageTypeSet,\n  PostMessageWithOrigin,\n  WireValue,\n  WireValueType,\n  wireValueTypeSet,\n  StoreKey,\n} from \"./protocol\";\n\nimport { requestResponseMessage } from \"./request_response\";\n\nimport { createEndpoint, Remote, releaseProxy } from \"./types\";\nimport { proxy } from \"./transfer_handlers\";\nimport {\n  fromWireValue,\n  toWireValue,\n  transfer,\n  throwMarker,\n  storeCreate,\n  storeGetValue,\n  storeDeleteKey,\n} from \"./transfer_handlers\";\n\nimport { SynclinkTask, syncResponse } from \"./task\";\n\nfunction innerMessageHandler(obj_arg: any, ep: Endpoint, message: Message) {\n  const { id, path, store_key } = {\n    path: [] as string[],\n    store_key: undefined,\n    ...message,\n  };\n  let obj;\n  if (store_key) {\n    obj = storeGetValue(ep, store_key);\n  } else {\n    obj = obj_arg;\n  }\n  if (obj_arg === undefined && store_key === undefined) {\n    console.warn(obj_arg, message);\n    throw new Error(\"Internal synclink error!\");\n  }\n  const argumentList = ((message as any).argumentList || []).map((v: any) => {\n    if (v.type === WireValueType.PROXY) {\n      return innerMessageHandler(obj_arg, ep, v.message);\n    } else {\n      return fromWireValue(ep, v);\n    }\n  });\n  const last = path.pop();\n  let parent = path.reduce((obj, prop) => obj[prop], obj);\n  const rawValue = last ? parent[last] : obj;\n  if (!last) {\n    parent = undefined;\n  }\n  if (rawValue === undefined) {\n    switch (message.type) {\n      case MessageType.GET:\n      case MessageType.SET:\n        break;\n      default:\n        console.warn(\"Undefined\", obj, path, last);\n        throw new Error(\"undefined!!\" + ` ${obj}, ${path}, ${last}`);\n    }\n  }\n  switch (message.type) {\n    case MessageType.GET:\n      {\n        return rawValue;\n      }\n      break;\n    case MessageType.SET:\n      {\n        parent[last!] = fromWireValue(ep, message.value);\n        return true;\n      }\n      break;\n    case MessageType.APPLY:\n      {\n        if (last) {\n          return parent[last].apply(parent, argumentList);\n        } else {\n          return rawValue.apply(parent, argumentList);\n        }\n      }\n      break;\n    case MessageType.CONSTRUCT:\n      {\n        const value = new rawValue(...argumentList);\n        return proxy(value);\n      }\n      break;\n    case MessageType.ENDPOINT:\n      {\n        const { port1, port2 } = new MessageChannel();\n        expose(obj, port2);\n        return transfer(port1, [port1]);\n      }\n      break;\n    case MessageType.RELEASE:\n      {\n        return undefined;\n      }\n      break;\n    case MessageType.DESTROY:\n      {\n        storeDeleteKey(ep, store_key!);\n        return undefined;\n      }\n      break;\n    default:\n      return undefined;\n  }\n}\n\nexport function expose(obj_arg: any, ep: Endpoint = globalThis as any) {\n  const wrap = false;\n  exposeInner(obj_arg, ep, wrap);\n}\n\nfunction exposeInner(\n  obj_arg: any,\n  ep: Endpoint = globalThis as any,\n  wrap: boolean,\n) {\n  storeCreate(ep);\n  ep.addEventListener(\"message\", async function callback(ev: MessageEvent) {\n    if (!ev || !ev.data) {\n      return;\n    }\n    if (!messageTypeSet.has(ev.data.type)) {\n      if (!wireValueTypeSet.has(ev.data.type) && !ev.data.data_buffer) {\n        console.warn(\"Internal error on message:\", ev.data);\n        throw new Error(\n          `Synclink Internal error: Expected message.type to either be a MessageType or a WireValueType, got '${ev.data.type}'`,\n        );\n      }\n      // It was a response.\n      // TODO: assert that there is a requestResponseMessage waiting for this id?\n      return;\n    }\n    const message = ev.data as Message;\n    const { id, type, store_key } = { store_key: undefined, ...message };\n    if (wrap && store_key === undefined) {\n      // TODO: What are these messages doing?\n      return;\n    }\n    const sync = ev.data.syncify;\n    let returnValue;\n    try {\n      returnValue = innerMessageHandler(obj_arg, ep, message);\n      if (returnValue && returnValue.then) {\n        if (sync && ep._bypass) {\n          throw new Error(\"Cannot use syncify with bypass on an async method\");\n        }\n        returnValue = await returnValue;\n      }\n    } catch (value) {\n      returnValue = { value, [throwMarker]: 0 };\n    }\n    const [wireValue, transferables] = toWireValue(ep, returnValue);\n    if (sync) {\n      syncResponse(ep, ev.data, wireValue);\n    } else {\n      ep.postMessage({ ...wireValue, id }, transferables);\n    }\n    if (type === MessageType.RELEASE) {\n      // detach and deactivate after sending release response above.\n      ep.removeEventListener(\"message\", callback as any);\n      closeEndPoint(ep);\n    }\n  } as any);\n  if (ep.start) {\n    ep.start();\n  }\n}\n\nfunction isMessagePort(endpoint: Endpoint): endpoint is MessagePort {\n  return endpoint.constructor.name === \"MessagePort\";\n}\n\nfunction closeEndPoint(endpoint: Endpoint) {\n  if (isMessagePort(endpoint)) endpoint.close();\n}\n\nexport function wrap<T>(ep: Endpoint, target?: any): Remote<T> {\n  const wrap = true;\n  exposeInner(undefined, ep, wrap);\n  return createProxy<T>(ep, { target }) as any;\n}\n\nfunction throwIfProxyReleased(isReleased: boolean) {\n  if (isReleased) {\n    throw new Error(\"Proxy has been released and is not usable\");\n  }\n}\n\nexport function createProxy<T>(\n  ep: Endpoint,\n  {\n    store_key = undefined,\n    path = [],\n    target = function () {},\n  }: {\n    store_key?: StoreKey;\n    path?: (string | number | symbol)[];\n    target?: object;\n  },\n): Remote<T> {\n  let isProxyReleased = false;\n  const proxy = new Proxy(target, {\n    get(_target, prop) {\n      throwIfProxyReleased(isProxyReleased);\n      switch (prop) {\n        case \"$$ep\":\n          return ep;\n        case Symbol.toStringTag:\n          return \"SynclinkProxy\";\n        case releaseProxy:\n          return () => {\n            return new SynclinkTask(\n              ep,\n              {\n                type: MessageType.RELEASE,\n                path: path.map((p) => p.toString()),\n              },\n              [],\n              () => {\n                closeEndPoint(ep);\n                isProxyReleased = true;\n              },\n            );\n          };\n        case \"__destroy__\":\n          if (!store_key) {\n            return () => {};\n          }\n          return () => {\n            return new SynclinkTask(\n              ep,\n              {\n                type: MessageType.DESTROY,\n                store_key,\n              },\n              [],\n              () => {\n                isProxyReleased = true;\n              },\n            );\n          };\n        case \"_as_message\":\n          return () => {\n            return {\n              type: MessageType.GET,\n              store_key,\n              path: path.map((p) => p.toString()),\n            };\n          };\n        case \"then\":\n        case \"schedule_async\":\n        case \"schedule_sync\":\n        case \"syncify\":\n          if (path.length === 0 && prop === \"then\") {\n            return { then: () => proxy };\n          }\n          let r = new SynclinkTask(\n            ep,\n            {\n              type: MessageType.GET,\n              store_key,\n              path: path.map((p) => p.toString()),\n            },\n            [],\n            undefined,\n          );\n          return r[prop].bind(r);\n        default:\n          return createProxy(ep, { store_key, path: [...path, prop] });\n      }\n    },\n    set(_target, prop, rawValue) {\n      throwIfProxyReleased(isProxyReleased);\n      // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\n      // boolean. To show good will, we return true asynchronously \u00AF\\_(\u30C4)_/\u00AF\n      const [value, transferables] = toWireValue(ep, rawValue);\n      return requestResponseMessage(\n        ep,\n        {\n          type: MessageType.SET,\n          store_key,\n          path: [...path, prop].map((p) => p.toString()),\n          value,\n        },\n        transferables,\n      ).then((v) => fromWireValue(ep, v)) as any;\n    },\n    apply(_target, _thisArg, rawArgumentList) {\n      throwIfProxyReleased(isProxyReleased);\n      const last = path[path.length - 1];\n      if ((last as any) === createEndpoint) {\n        return requestResponseMessage(ep, {\n          type: MessageType.ENDPOINT,\n        }).then((v) => fromWireValue(ep, v));\n      }\n      // We just pretend that `bind()` didn\u2019t happen.\n      if (last === \"bind\") {\n        return createProxy(ep, { store_key, path: path.slice(0, -1) });\n      }\n      if (last === \"apply\") {\n        // temporary hack...\n        rawArgumentList = rawArgumentList[1];\n        path = path.slice(0, -1);\n      }\n      const [argumentList, transferables] = processArguments(\n        ep,\n        rawArgumentList,\n      );\n      return new SynclinkTask(\n        ep,\n        {\n          type: MessageType.APPLY,\n          store_key,\n          path: path.map((p) => p.toString()),\n          argumentList,\n        },\n        transferables,\n        undefined,\n      );\n    },\n    construct(_target, rawArgumentList) {\n      throwIfProxyReleased(isProxyReleased);\n      const [argumentList, transferables] = processArguments(\n        ep,\n        rawArgumentList,\n      );\n      return requestResponseMessage(\n        ep,\n        {\n          type: MessageType.CONSTRUCT,\n          store_key,\n          path: path.map((p) => p.toString()),\n          argumentList,\n        },\n        transferables,\n      ).then((v) => fromWireValue(ep, v));\n    },\n    ownKeys(_target) {\n      return [];\n    },\n  });\n  return proxy as any;\n}\n\nfunction myFlat<T>(arr: (T | T[])[]): T[] {\n  return Array.prototype.concat.apply([], arr);\n}\n\nfunction processArguments(\n  ep: Endpoint,\n  argumentList: any[],\n): [WireValue[], Transferable[]] {\n  const processed = argumentList.map((v) => toWireValue(ep, v));\n  return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];\n}\n\nexport function windowEndpoint(\n  w: PostMessageWithOrigin,\n  context: EventSource = self,\n  targetOrigin = \"*\",\n): Endpoint {\n  return {\n    postMessage: (msg: any, transferables: Transferable[]) =>\n      w.postMessage(msg, targetOrigin, transferables),\n    addEventListener: context.addEventListener.bind(context),\n    removeEventListener: context.removeEventListener.bind(context),\n  };\n}\n", "class FakeMessagePort {\n  _otherPort: FakeMessagePort;\n  _handlers: ((msg: { data: any }) => void)[] = [];\n  _bypass: boolean = true;\n  start() {}\n  close() {}\n\n  constructor() {\n    this._otherPort = this;\n  }\n\n  addEventListener(event: string, handler: (msg: { data: any }) => void) {\n    if (event === \"message\") {\n      this._handlers.push(handler);\n    }\n  }\n\n  removeEventListener(event: string, handler: (msg: { data: any }) => void) {\n    if (event !== \"message\") {\n      return;\n    }\n    let idx = this._handlers.indexOf(handler);\n    if (idx >= 0) {\n      this._handlers.splice(idx, 1);\n    }\n  }\n\n  postMessage(message: any, transfer: Transferable[]) {\n    for (const h of this._otherPort._handlers) {\n      h({ data: message });\n    }\n  }\n}\n\nclass FakeMessageChannel {\n  port1: FakeMessagePort;\n  port2: FakeMessagePort;\n  constructor() {\n    this.port1 = new FakeMessagePort();\n    this.port2 = new FakeMessagePort();\n    this.port1._otherPort = this.port2;\n    this.port2._otherPort = this.port1;\n  }\n}\n\nlet FakeMessageChannel1 =\n  FakeMessageChannel as unknown as typeof MessageChannel;\n\nexport { FakeMessageChannel1 as FakeMessageChannel };\n", "import { Endpoint, WireValue, WireValueType, StoreKey } from \"./protocol\";\nimport { generateUUID } from \"./request_response\";\nimport { createProxy, expose, wrap } from \"./async_task\";\nimport { FakeMessageChannel } from \"./fake_message_channel\";\nimport { ProxyMarked, proxyMarker } from \"./types\";\n\nexport const throwMarker = Symbol(\"Synclink.thrown\");\n\nconst transferCache = new WeakMap<any, Transferable[]>();\nexport function transfer<T>(obj: T, transfers: Transferable[]): T {\n  transferCache.set(obj, transfers);\n  return obj;\n}\n\nexport const isObject = (val: unknown): val is object =>\n  (typeof val === \"object\" && val !== null) || typeof val === \"function\";\n\n/**\n * Customizes the serialization of certain values as determined by `canHandle()`.\n *\n * @template T The input type being handled by this transfer handler.\n * @template S The serialized type sent over the wire.\n */\nexport interface TransferHandler<T, S> {\n  /**\n   * Gets called for every value to determine whether this transfer handler\n   * should serialize the value, which includes checking that it is of the right\n   * type (but can perform checks beyond that as well).\n   */\n  canHandle(value: unknown): value is T;\n\n  /**\n   * Gets called with the value if `canHandle()` returned `true` to produce a\n   * value that can be sent in a message, consisting of structured-cloneable\n   * values and/or transferrable objects.\n   */\n  serialize(value: T): [S, Transferable[]];\n\n  /**\n   * Gets called to deserialize an incoming value that was serialized in the\n   * other thread with this transfer handler (known through the name it was\n   * registered under).\n   */\n  deserialize(value: S): T;\n}\n\n/**\n * Allows customizing the serialization of certain values.\n */\nexport const transferHandlers = new Map<\n  string,\n  TransferHandler<unknown, unknown>\n>();\n\nfunction isArrayBufferOrView(obj: any): boolean {\n  return (\n    ArrayBuffer.isView(obj) ||\n    Object.prototype.toString.call(obj) === \"[object ArrayBuffer]\"\n  );\n}\n\nfunction isPlain(val: any) {\n  return (\n    !val ||\n    typeof val === \"string\" ||\n    typeof val === \"boolean\" ||\n    typeof val === \"number\" ||\n    Array.isArray(val) ||\n    isArrayBufferOrView(val) ||\n    !val.constructor ||\n    (val.constructor === Object &&\n      Object.prototype.toString.call(val) === \"[object Object]\")\n  );\n}\n\nfunction isSerializable(obj: any, transfers: Transferable[] = []) {\n  if (transfers.includes(obj)) {\n    return true;\n  }\n  if (!isPlain(obj)) {\n    return false;\n  }\n  for (var property in obj) {\n    if (obj.hasOwnProperty(property)) {\n      if (!isPlain(obj[property])) {\n        return false;\n      }\n      if (typeof obj[property] == \"object\") {\n        if (!isSerializable(obj[property], transfers)) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}\n\ninterface ThrownValue {\n  [throwMarker]: unknown; // just needs to be present\n  value: unknown;\n}\ntype SerializedThrownValue =\n  | { isError: true; value: Error }\n  | { isError: false; value: unknown };\n\n/**\n * Internal transfer handler to handle thrown exceptions.\n */\nexport const throwTransferHandler: TransferHandler<\n  ThrownValue,\n  SerializedThrownValue\n> = {\n  canHandle: (value): value is ThrownValue =>\n    isObject(value) && throwMarker in value,\n  serialize({ value }) {\n    let serialized: SerializedThrownValue;\n    if (value instanceof Error) {\n      serialized = {\n        isError: true,\n        value: {\n          message: value.message,\n          name: value.name,\n          stack: value.stack,\n        },\n      };\n    } else {\n      serialized = { isError: false, value };\n    }\n    return [serialized, []];\n  },\n  deserialize(serialized) {\n    if (serialized.isError) {\n      throw Object.assign(\n        new Error(serialized.value.message),\n        serialized.value,\n      );\n    }\n    throw serialized.value;\n  },\n};\n\nexport function toWireValue(\n  ep: Endpoint,\n  value: any,\n): [WireValue, Transferable[]] {\n  if (value && value.$$ep === ep) {\n    return [\n      {\n        type: WireValueType.PROXY,\n        message: value._as_message(),\n      },\n      [],\n    ];\n  }\n  if (value && value.constructor && value.constructor.name === \"SynclinkTask\") {\n    return [\n      {\n        type: WireValueType.PROXY,\n        message: value.msg,\n      },\n      [],\n    ];\n  }\n  if (ep._bypass) {\n    proxyFakeMessagePort = true;\n  }\n  try {\n    for (const [name, handler] of transferHandlers) {\n      if (handler.canHandle(value)) {\n        const [serializedValue, transferables] = handler.serialize(value);\n        return [\n          {\n            type: WireValueType.HANDLER,\n            name,\n            value: serializedValue,\n          },\n          transferables,\n        ];\n      }\n    }\n  } finally {\n    proxyFakeMessagePort = false;\n  }\n  if (isSerializable(value, transferCache.get(value))) {\n    return [\n      {\n        type: WireValueType.RAW,\n        value,\n      },\n      transferCache.get(value) || [],\n    ];\n  }\n  let store_key = storeNewValue(ep, value);\n  return [\n    {\n      type: WireValueType.ID,\n      store_key,\n      endpoint_uuid: (ep as any)[endpointUUID],\n      ownkeys: Object.getOwnPropertyNames(value),\n    },\n    [],\n  ];\n}\n\nexport function fromWireValue(ep: Endpoint, value: WireValue): any {\n  switch (value.type) {\n    case WireValueType.HANDLER:\n      return transferHandlers.get(value.name)!.deserialize(value.value);\n    case WireValueType.RAW:\n      return value.value;\n    case WireValueType.ID:\n      let this_uuid = (ep as any)[endpointUUID];\n      if (this_uuid === value.endpoint_uuid) {\n        return storeGetValue(ep, value.store_key);\n      } else {\n        return createProxy(ep, { store_key: value.store_key });\n      }\n  }\n}\n\nconst proxyStore = Symbol(\"Synclink.proxyStore\");\nconst endpointUUID = Symbol(\"Synclink.endpointUUID\");\n\nexport function storeCreate(obj: any) {\n  if (proxyStore in obj) {\n    return;\n  }\n  obj[proxyStore] = { objects: new Map(), counter: new Uint32Array([1]) };\n  obj[endpointUUID] = generateUUID();\n}\n\nexport function storeGetValue(obj: any, key: StoreKey) {\n  return obj[proxyStore].objects.get(key);\n}\n\nexport function storeNewValue(obj: any, value: any): StoreKey {\n  if (!(proxyStore in obj)) {\n    storeCreate(obj);\n  }\n  let { objects, counter } = obj[proxyStore];\n  while (objects.has(counter[0])) {\n    // Increment by two here (and below) because even integers are reserved\n    // for singleton constants\n    counter[0] += 2;\n  }\n  let key = counter[0];\n  counter[0] += 2;\n  objects.set(key, value);\n  return key;\n}\n\nexport function storeDeleteKey(obj: any, key: StoreKey): any {\n  let { objects } = obj[proxyStore];\n  objects.delete(key);\n  console.log(\"deleted\", key, objects);\n}\n\nexport function proxy<T>(obj: T): T & ProxyMarked {\n  return Object.assign(obj as any, { [proxyMarker]: true }) as any;\n}\n\nlet proxyFakeMessagePort = false;\n\n/**\n * Internal transfer handle to handle objects marked to proxy.\n */\nexport const proxyTransferHandler: TransferHandler<object, MessagePort> = {\n  canHandle: (val): val is ProxyMarked =>\n    isObject(val) && (val as ProxyMarked)[proxyMarker],\n  serialize(obj) {\n    const { port1, port2 } = (\n      proxyFakeMessagePort ? new FakeMessageChannel() : new MessageChannel()\n    ) as MessageChannel;\n    expose(obj, port1);\n    return [port2, [port2]];\n  },\n  deserialize(port) {\n    port.start();\n    return wrap(port);\n  },\n};\n"],
  "mappings": "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",
  "names": ["size", "obj", "wrap", "proxy", "transfer"]
}
