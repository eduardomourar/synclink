"use strict";
var Synclink = (() => {
  var k = Object.defineProperty,
    _e = Object.defineProperties,
    Me = Object.getOwnPropertyDescriptor,
    Pe = Object.getOwnPropertyDescriptors,
    Ae = Object.getOwnPropertyNames,
    Q = Object.getOwnPropertySymbols;
  var re = Object.prototype.hasOwnProperty,
    Re = Object.prototype.propertyIsEnumerable;
  var te = Math.pow,
    ee = (e, r, t) =>
      r in e
        ? k(e, r, { enumerable: !0, configurable: !0, writable: !0, value: t })
        : (e[r] = t),
    T = (e, r) => {
      for (var t in (r ||= {})) re.call(r, t) && ee(e, t, r[t]);
      if (Q) for (var t of Q(r)) Re.call(r, t) && ee(e, t, r[t]);
      return e;
    },
    A = (e, r) => _e(e, Pe(r)),
    a = (e, r) => k(e, "name", { value: r, configurable: !0 });
  var Ie = (e, r) => {
      for (var t in r) k(e, t, { get: r[t], enumerable: !0 });
    },
    Oe = (e, r, t, s) => {
      if ((r && typeof r == "object") || typeof r == "function")
        for (let n of Ae(r))
          !re.call(e, n) &&
            n !== t &&
            k(e, n, {
              get: () => r[n],
              enumerable: !(s = Me(r, n)) || s.enumerable,
            });
      return e;
    };
  var Ve = (e) => Oe(k({}, "__esModule", { value: !0 }), e);
  var g = (e, r, t) =>
    new Promise((s, n) => {
      var c = (o) => {
          try {
            l(t.next(o));
          } catch (i) {
            n(i);
          }
        },
        u = (o) => {
          try {
            l(t.throw(o));
          } catch (i) {
            n(i);
          }
        },
        l = (o) => (o.done ? s(o.value) : Promise.resolve(o.value).then(c, u));
      l((t = t.apply(e, r)).next());
    });
  var ze = {};
  Ie(ze, {
    FakeMessageChannel: () => j,
    Syncifier: () => b,
    createEndpoint: () => I,
    expose: () => M,
    interrupt_buffer: () => W,
    proxy: () => C,
    proxyMarker: () => E,
    releaseProxy: () => O,
    setInterruptHandler: () => fe,
    transfer: () => U,
    transferHandlers: () => m,
    windowEndpoint: () => he,
    wrap: () => v,
  });
  var Le = {
      ["RAW"]: 1,
      ["PROXY"]: 1,
      ["THROW"]: 1,
      ["HANDLER"]: 1,
      ["ID"]: 1,
    },
    ne = new Set(Object.keys(Le));
  var We = {
      ["SET"]: 1,
      ["GET"]: 1,
      ["APPLY"]: 1,
      ["CONSTRUCT"]: 1,
      ["ENDPOINT"]: 1,
      ["RELEASE"]: 1,
      ["DESTROY"]: 1,
    },
    se = new Set(Object.keys(We));
  function z(e) {
    let r = Y();
    return [
      r,
      new Promise((t) => {
        e.addEventListener(
          "message",
          a(function s(n) {
            !n.data ||
              !n.data.id ||
              n.data.id !== r ||
              (e.removeEventListener("message", s), t(n.data));
          }, "l"),
        ),
          e.start && e.start();
      }),
    ];
  }
  a(z, "requestResponseMessageInner");
  function w(e, r, t) {
    let [s, n] = z(e);
    return e.postMessage(T({ id: s }, r), t), n;
  }
  a(w, "requestResponseMessage");
  var R = 63;
  function De() {
    let e = Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16),
      r = 15 - e.length;
    return r > 0 && (e = Array.from({ length: r }, (t) => 0).join("") + e), e;
  }
  a(De, "randomSegment");
  function Y() {
    let e = Array.from({ length: 4 }, De).join("-");
    if (e.length !== R)
      throw new Error("synclink internal error: UUID has the wrong length");
    return e;
  }
  a(Y, "generateUUID");
  var I = Symbol("Synclink.endpoint"),
    O = Symbol("Synclink.releaseProxy"),
    E = Symbol("Synclink.proxy");
  var G;
  typeof SharedArrayBuffer == "undefined"
    ? (G = ArrayBuffer)
    : (G = SharedArrayBuffer);
  var S = G;
  var ae = new TextDecoder("utf-8"),
    oe = new TextEncoder(),
    B = 0,
    K = 1,
    ve = 0;
  function ue(e) {
    return new Promise((r) => setTimeout(r, e));
  }
  a(ue, "sleep");
  var h = class {
    constructor(r, t, s = [], n = () => {}) {
      (this.endpoint = r),
        (this.msg = t),
        (this.extra = n),
        (this.transfers = s),
        (this._resolved = !1),
        (this._promise = new Promise((c, u) => {
          (this._resolve = c), (this._reject = u);
        }));
    }
    schedule_async() {
      if (this.mode === "async") return this;
      if (this.mode === "sync")
        throw new Error("Already synchronously scheduled");
      return (
        (this.mode = "async"),
        this.do_async().then(
          (r) => {
            (this._resolved = !0), (this._result = r), this._resolve(r);
          },
          (r) => {
            (this._exception = r), this._reject(r);
          },
        ),
        this
      );
    }
    then(r, t) {
      return g(this, null, function* () {
        return this.schedule_async(), this._promise.then(r, t);
      });
    }
    catch(r) {
      return this.schedule_async(), this._promise.catch(r);
    }
    finally(r) {
      return this.schedule_async(), this._promise.finally(r);
    }
    schedule_sync() {
      if (this.mode === "sync") return this;
      if (this.mode === "async")
        throw new Error("Already asynchronously scheduled");
      return (
        (this.mode = "sync"),
        b.scheduleTask(this),
        (this._sync_gen = this.do_sync()),
        this._sync_gen.next(),
        this
      );
    }
    isResolved() {
      return this._resolved;
    }
    poll() {
      if (this.mode != "sync")
        throw new Error("Task not synchronously scheduled");
      let { done: r, value: t } = this._sync_gen.next();
      if (!r) return !1;
      try {
        (this._resolved = !0), (this._result = p(this.endpoint, t));
      } catch (s) {
        console.warn("synclink exception:", s), (this._exception = s);
      }
      return !0;
    }
    *do_sync() {
      let { endpoint: r, msg: t, transfers: s } = this,
        n = new Int32Array(new S(8)),
        c = this.signal_buffer,
        u = this.taskId,
        l = le(R);
      if (
        (r.postMessage(
          A(T({}, t), {
            size_buffer: n,
            data_buffer: l,
            signal_buffer: c,
            taskId: u,
            syncify: !0,
          }),
          s,
        ),
        yield,
        Atomics.load(n, K) === ve)
      ) {
        let i = ae.decode(l.slice(0, R));
        Ue(l);
        let y = Atomics.load(n, B);
        (l = le(y)), r.postMessage({ id: i, data_buffer: l }), yield;
      }
      let o = Atomics.load(n, B);
      return JSON.parse(ae.decode(l.slice(0, o)));
    }
    do_async() {
      return g(this, null, function* () {
        let r = yield w(this.endpoint, this.msg, this.transfers);
        return this.extra(), p(this.endpoint, r);
      });
    }
    get result() {
      if (this._exception) throw this._exception;
      if (this.isResolved()) return this._result;
      throw new Error("Not ready.");
    }
    syncify() {
      return this.schedule_sync(), b.syncifyTask(this), this.result;
    }
  };
  a(h, "SynclinkTask");
  function ie(e, r) {
    return g(this, null, function* () {
      let t = (r >> 1) % 32,
        s = 1;
      for (; Atomics.compareExchange(e, t + 1, 0, r) !== 0; )
        yield ue(s), s < 32 && (s *= 2);
      Atomics.or(e, 0, 1 << t), Atomics.notify(e, 0);
    });
  }
  a(ie, "signalRequester");
  function ye(e, r, t) {
    return g(this, null, function* () {
      try {
        let { size_buffer: s, data_buffer: n, signal_buffer: c, taskId: u } = r,
          l = oe.encode(JSON.stringify(t)),
          o = l.length <= n.length;
        if ((Atomics.store(s, B, l.length), Atomics.store(s, K, +o), !o)) {
          let [i, y] = z(e);
          n.set(oe.encode(i)), yield ie(c, u), (n = (yield y).data_buffer);
        }
        n.set(l), Atomics.store(s, K, 1), yield ie(c, u);
      } catch (s) {
        console.warn(s);
      }
    });
  }
  a(ye, "syncResponse");
  var V = [];
  function le(e) {
    let r = Math.ceil(Math.log2(e));
    V[r] || (V[r] = []);
    let t = V[r].pop();
    return t ? (t.fill(0), t) : new Uint8Array(new S(te(2, r)));
  }
  a(le, "acquireDataBuffer");
  function Ue(e) {
    let r = Math.ceil(Math.log2(e.byteLength));
    V[r].push(e);
  }
  a(Ue, "releaseDataBuffer");
  var W = new Int32Array(new S(4)),
    ce = a(() => {
      throw ((W[0] = 0), new Error("Interrupted!"));
    }, "handleInterrupt");
  function fe(e) {
    ce = e;
  }
  a(fe, "setInterruptHandler");
  var L = class {
    constructor() {
      (this.nextTaskId = new Int32Array([1])),
        (this.signal_buffer = new Int32Array(new S(32 * 4 + 4))),
        (this.tasks = new Map());
    }
    scheduleTask(r) {
      (r.taskId = this.nextTaskId[0]),
        (this.nextTaskId[0] += 2),
        (r.signal_buffer = this.signal_buffer),
        this.tasks.set(r.taskId, r);
    }
    waitOnSignalBuffer() {
      console.log("waiting on signal buffer");
      let r = 50;
      for (;;)
        switch (Atomics.wait(this.signal_buffer, 0, 0, r)) {
          case "ok":
          case "not-equal":
            console.log("finished waiting on signal buffer");
            return;
          case "timed-out":
            W[0] !== 0 && ce();
            break;
          default:
            throw new Error("Unreachable");
        }
    }
    *tasksIdsToWakeup() {
      let r = Atomics.load(this.signal_buffer, 0);
      for (let t = 0; t < 32; t++) {
        let s = 1 << t;
        r & s &&
          (Atomics.and(this.signal_buffer, 0, ~s),
          yield Atomics.exchange(this.signal_buffer, t + 1, 0));
      }
    }
    pollTasks(r) {
      let t = !1;
      if (!r && this.tasks.size < 1) return !0;
      for (let s of this.tasksIdsToWakeup()) {
        console.log("poll task", s, "looking for", r);
        let n = this.tasks.get(s);
        if (!n) throw new Error(`Assertion error: unknown taskId ${s}.`);
        n.poll() &&
          (console.log("completed task ", s, n, n._result),
          this.tasks.delete(s),
          n === r && (t = !0));
      }
      return t;
    }
    syncifyTask(r) {
      for (;;) {
        if (this.pollTasks(r)) return;
        if (r.endpoint._bypass) throw new Error("oops!");
        this.waitOnSignalBuffer();
      }
    }
  };
  a(L, "_Syncifier");
  var b = new L();
  a(function () {
    return g(this, null, function* () {
      for (;;) {
        if (b.pollTasks()) return;
        yield ue(20);
      }
    });
  }, "syncifyPollLoop")();
  function pe(e, r, t) {
    let {
        id: s,
        path: n,
        store_key: c,
      } = T({ path: [], store_key: void 0 }, t),
      u;
    if ((c ? (u = $(r, c)) : (u = e), e === void 0 && c === void 0))
      throw (console.warn(e, t), new Error("Internal synclink error!"));
    let l = (t.argumentList || []).map((f) =>
        f.type === "PROXY" ? pe(e, r, f.message) : p(r, f),
      ),
      o = n.pop(),
      i = n.reduce((f, d) => f[d], u),
      y = o ? i[o] : u;
    if ((o || (i = void 0), y === void 0))
      switch (t.type) {
        case "GET":
        case "SET":
          break;
        default:
          throw (
            (console.warn("Undefined", u, n, o),
            new Error(`undefined!! ${u}, ${n}, ${o}`))
          );
      }
    switch (t.type) {
      case "GET":
        return y;
      case "SET":
        return (i[o] = p(r, t.value)), !0;
      case "APPLY":
        return o ? i[o].apply(i, l) : y.apply(i, l);
      case "CONSTRUCT":
        {
          let f = new y(...l);
          return C(f);
        }
        break;
      case "ENDPOINT":
        {
          let { port1: f, port2: d } = new MessageChannel();
          return M(u, d), U(f, [f]);
        }
        break;
      case "RELEASE":
        return;
      case "DESTROY":
        {
          me(r, c);
          return;
        }
        break;
      default:
        return;
    }
  }
  a(pe, "innerMessageHandler");
  function M(e, r = globalThis) {
    Te(e, r, !1);
  }
  a(M, "expose");
  function Te(e, r = globalThis, t) {
    X(r),
      r.addEventListener(
        "message",
        a(function s(n) {
          return g(this, null, function* () {
            if (!n || !n.data) return;
            if (!se.has(n.data.type)) {
              if (!ne.has(n.data.type) && !n.data.data_buffer)
                throw (
                  (console.warn("Internal error on message:", n.data),
                  new Error(
                    `Synclink Internal error: Expected message.type to either be a MessageType or a WireValueType, got '${n.data.type}'`,
                  ))
                );
              return;
            }
            let c = n.data,
              { id: u, type: l, store_key: o } = T({ store_key: void 0 }, c);
            if (t && o === void 0) return;
            let i = n.data.syncify,
              y;
            try {
              if (((y = pe(e, r, c)), y && y.then)) {
                if (i && r._bypass)
                  throw new Error(
                    "Cannot use syncify with bypass on an async method",
                  );
                y = yield y;
              }
            } catch (be) {
              y = { value: be, [F]: 0 };
            }
            let [f, d] = H(r, y);
            i ? ye(r, n.data, f) : r.postMessage(A(T({}, f), { id: u }), d),
              l === "RELEASE" && (r.removeEventListener("message", s), ge(r));
          });
        }, "callback"),
      ),
      r.start && r.start();
  }
  a(Te, "exposeInner");
  function He(e) {
    return e.constructor.name === "MessagePort";
  }
  a(He, "isMessagePort");
  function ge(e) {
    He(e) && e.close();
  }
  a(ge, "closeEndPoint");
  function v(e, r) {
    return Te(void 0, e, !0), _(e, { target: r });
  }
  a(v, "wrap");
  function D(e) {
    if (e) throw new Error("Proxy has been released and is not usable");
  }
  a(D, "throwIfProxyReleased");
  function _(
    e,
    {
      store_key: r = void 0,
      path: t = [],
      target: s = a(function () {}, "target"),
    },
  ) {
    let n = !1,
      c = new Proxy(s, {
        get(u, l) {
          switch ((D(n), l)) {
            case "$$ep":
              return e;
            case Symbol.toStringTag:
              return "SynclinkProxy";
            case O:
              return () =>
                new h(
                  e,
                  { type: "RELEASE", path: t.map((i) => i.toString()) },
                  [],
                  () => {
                    ge(e), (n = !0);
                  },
                );
            case "__destroy__":
              return r
                ? () =>
                    new h(e, { type: "DESTROY", store_key: r }, [], () => {
                      n = !0;
                    })
                : () => {};
            case "_as_message":
              return () => ({
                type: "GET",
                store_key: r,
                path: t.map((i) => i.toString()),
              });
            case "then":
            case "schedule_async":
            case "schedule_sync":
            case "syncify":
              if (t.length === 0 && l === "then") return { then: () => c };
              let o = new h(
                e,
                { type: "GET", store_key: r, path: t.map((i) => i.toString()) },
                [],
                void 0,
              );
              return o[l].bind(o);
            default:
              return _(e, { store_key: r, path: [...t, l] });
          }
        },
        set(u, l, o) {
          D(n);
          let [i, y] = H(e, o);
          return w(
            e,
            {
              type: "SET",
              store_key: r,
              path: [...t, l].map((f) => f.toString()),
              value: i,
            },
            y,
          ).then((f) => p(e, f));
        },
        apply(u, l, o) {
          D(n);
          let i = t[t.length - 1];
          if (i === I) return w(e, { type: "ENDPOINT" }).then((d) => p(e, d));
          if (i === "bind") return _(e, { store_key: r, path: t.slice(0, -1) });
          i === "apply" && ((o = o[1]), (t = t.slice(0, -1)));
          let [y, f] = de(e, o);
          return new h(
            e,
            {
              type: "APPLY",
              store_key: r,
              path: t.map((d) => d.toString()),
              argumentList: y,
            },
            f,
            void 0,
          );
        },
        construct(u, l) {
          D(n);
          let [o, i] = de(e, l);
          return w(
            e,
            {
              type: "CONSTRUCT",
              store_key: r,
              path: t.map((y) => y.toString()),
              argumentList: o,
            },
            i,
          ).then((y) => p(e, y));
        },
        ownKeys(u) {
          return [];
        },
      });
    return c;
  }
  a(_, "createProxy");
  function Ce(e) {
    return Array.prototype.concat.apply([], e);
  }
  a(Ce, "myFlat");
  function de(e, r) {
    let t = r.map((s) => H(e, s));
    return [t.map((s) => s[0]), Ce(t.map((s) => s[1]))];
  }
  a(de, "processArguments");
  function he(e, r = self, t = "*") {
    return {
      postMessage: (s, n) => e.postMessage(s, t, n),
      addEventListener: r.addEventListener.bind(r),
      removeEventListener: r.removeEventListener.bind(r),
    };
  }
  a(he, "windowEndpoint");
  var P = class {
    constructor() {
      this._handlers = [];
      this._bypass = !0;
      this._otherPort = this;
    }
    start() {}
    close() {}
    addEventListener(r, t) {
      r === "message" && this._handlers.push(t);
    }
    removeEventListener(r, t) {
      if (r !== "message") return;
      let s = this._handlers.indexOf(t);
      s >= 0 && this._handlers.splice(s, 1);
    }
    postMessage(r, t) {
      for (let s of this._otherPort._handlers) s({ data: r });
    }
  };
  a(P, "FakeMessagePort");
  var N = class {
    constructor() {
      (this.port1 = new P()),
        (this.port2 = new P()),
        (this.port1._otherPort = this.port2),
        (this.port2._otherPort = this.port1);
    }
  };
  a(N, "FakeMessageChannel");
  var j = N;
  var F = Symbol("Synclink.thrown"),
    q = new WeakMap();
  function U(e, r) {
    return q.set(e, r), e;
  }
  a(U, "transfer");
  var xe = a(
      (e) => (typeof e == "object" && e !== null) || typeof e == "function",
      "isObject",
    ),
    m = new Map();
  function Ne(e) {
    return (
      ArrayBuffer.isView(e) ||
      Object.prototype.toString.call(e) === "[object ArrayBuffer]"
    );
  }
  a(Ne, "isArrayBufferOrView");
  function we(e) {
    return (
      !e ||
      typeof e == "string" ||
      typeof e == "boolean" ||
      typeof e == "number" ||
      Array.isArray(e) ||
      Ne(e) ||
      !e.constructor ||
      (e.constructor === Object &&
        Object.prototype.toString.call(e) === "[object Object]")
    );
  }
  a(we, "isPlain");
  function ke(e, r = []) {
    if (r.includes(e)) return !0;
    if (!we(e)) return !1;
    for (var t in e)
      if (
        e.hasOwnProperty(t) &&
        (!we(e[t]) || (typeof e[t] == "object" && !ke(e[t], r)))
      )
        return !1;
    return !0;
  }
  a(ke, "isSerializable");
  var Ee = {
    canHandle: (e) => xe(e) && F in e,
    serialize({ value: e }) {
      let r;
      return (
        e instanceof Error
          ? (r = {
              isError: !0,
              value: { message: e.message, name: e.name, stack: e.stack },
            })
          : (r = { isError: !1, value: e }),
        [r, []]
      );
    },
    deserialize(e) {
      throw e.isError
        ? Object.assign(new Error(e.value.message), e.value)
        : e.value;
    },
  };
  function H(e, r) {
    if (r && r.$$ep === e)
      return [{ type: "PROXY", message: r._as_message() }, []];
    if (r && r.constructor && r.constructor.name === "SynclinkTask")
      return [{ type: "PROXY", message: r.msg }, []];
    e._bypass && (Z = !0);
    try {
      for (let [s, n] of m)
        if (n.canHandle(r)) {
          let [c, u] = n.serialize(r);
          return [{ type: "HANDLER", name: s, value: c }, u];
        }
    } finally {
      Z = !1;
    }
    if (ke(r, q.get(r))) return [{ type: "RAW", value: r }, q.get(r) || []];
    let t = je(e, r);
    return [
      {
        type: "ID",
        store_key: t,
        endpoint_uuid: e[J],
        ownkeys: Object.getOwnPropertyNames(r),
      },
      [],
    ];
  }
  a(H, "toWireValue");
  function p(e, r) {
    switch (r.type) {
      case "HANDLER":
        return m.get(r.name).deserialize(r.value);
      case "RAW":
        return r.value;
      case "ID":
        return e[J] === r.endpoint_uuid
          ? $(e, r.store_key)
          : _(e, { store_key: r.store_key });
    }
  }
  a(p, "fromWireValue");
  var x = Symbol("Synclink.proxyStore"),
    J = Symbol("Synclink.endpointUUID");
  function X(e) {
    x in e ||
      ((e[x] = { objects: new Map(), counter: new Uint32Array([1]) }),
      (e[J] = Y()));
  }
  a(X, "storeCreate");
  function $(e, r) {
    return e[x].objects.get(r);
  }
  a($, "storeGetValue");
  function je(e, r) {
    x in e || X(e);
    let { objects: t, counter: s } = e[x];
    for (; t.has(s[0]); ) s[0] += 2;
    let n = s[0];
    return (s[0] += 2), t.set(n, r), n;
  }
  a(je, "storeNewValue");
  function me(e, r) {
    let { objects: t } = e[x];
    t.delete(r), console.log("deleted", r, t);
  }
  a(me, "storeDeleteKey");
  function C(e) {
    return Object.assign(e, { [E]: !0 });
  }
  a(C, "proxy");
  var Z = !1,
    Se = {
      canHandle: (e) => xe(e) && e[E],
      serialize(e) {
        let { port1: r, port2: t } = Z ? new j() : new MessageChannel();
        return M(e, r), [t, [t]];
      },
      deserialize(e) {
        return e.start(), v(e);
      },
    };
  m.set("throw", Ee);
  m.set("proxy", Se);
  m.set("headers", {
    canHandle(e) {
      return Object.prototype.toString.call(e) === "[object Headers]";
    },
    serialize(e) {
      return [Array.from(e), []];
    },
    deserialize(e) {
      return new Headers(e);
    },
  });
  return Ve(ze);
})();
//# sourceMappingURL=synclink.min.js.map
